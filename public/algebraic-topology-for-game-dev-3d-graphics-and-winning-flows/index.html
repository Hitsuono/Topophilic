<!DOCTYPE html>
<html lang="en-US">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="http://localhost:1313/images/favicon.png" />
<title>Algebraic topology for game dev: 3D graphics and winning flows | Topophilic</title>
<meta name="title" content="Algebraic topology for game dev: 3D graphics and winning flows" />
<meta name="description" content="TL;DR
In our search for topological invariants, we&rsquo;ll learn how holes can be defined and be used to study spaces. This will require studying &ldquo;model&rdquo; spaces, known as simplicial complexes, which are widely used in 3D rendering. We will be able to define general topological concepts like &ldquo;boundary&rdquo; and &ldquo;cycle&rdquo;. This will be formalized through a quick detour on group theory, the study of permutations and their algebras, which can be exemplified by the moves and configurations of a Rubik&rsquo;s cube. With this machinery, we&rsquo;ll define the homology groups of a topological space, in which holes live, and are one of the most important and studied topological invariants of spaces." />
<meta name="keywords" content="Topology for Artists," />


<meta property="og:url" content="http://localhost:1313/algebraic-topology-for-game-dev-3d-graphics-and-winning-flows/">
  <meta property="og:site_name" content="Topophilic">
  <meta property="og:title" content="Algebraic topology for game dev: 3D graphics and winning flows">
  <meta property="og:description" content="TL;DR In our search for topological invariants, we’ll learn how holes can be defined and be used to study spaces. This will require studying “model” spaces, known as simplicial complexes, which are widely used in 3D rendering. We will be able to define general topological concepts like “boundary” and “cycle”. This will be formalized through a quick detour on group theory, the study of permutations and their algebras, which can be exemplified by the moves and configurations of a Rubik’s cube. With this machinery, we’ll define the homology groups of a topological space, in which holes live, and are one of the most important and studied topological invariants of spaces.">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2025-01-14T12:33:23-03:00">
    <meta property="article:modified_time" content="2025-01-14T12:33:23-03:00">
    <meta property="article:tag" content="Topology for Artists">
    <meta property="og:image" content="http://localhost:1313/images/share.png">




  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/images/share.png">
  <meta name="twitter:title" content="Algebraic topology for game dev: 3D graphics and winning flows">
  <meta name="twitter:description" content="TL;DR In our search for topological invariants, we’ll learn how holes can be defined and be used to study spaces. This will require studying “model” spaces, known as simplicial complexes, which are widely used in 3D rendering. We will be able to define general topological concepts like “boundary” and “cycle”. This will be formalized through a quick detour on group theory, the study of permutations and their algebras, which can be exemplified by the moves and configurations of a Rubik’s cube. With this machinery, we’ll define the homology groups of a topological space, in which holes live, and are one of the most important and studied topological invariants of spaces.">




  <meta itemprop="name" content="Algebraic topology for game dev: 3D graphics and winning flows">
  <meta itemprop="description" content="TL;DR In our search for topological invariants, we’ll learn how holes can be defined and be used to study spaces. This will require studying “model” spaces, known as simplicial complexes, which are widely used in 3D rendering. We will be able to define general topological concepts like “boundary” and “cycle”. This will be formalized through a quick detour on group theory, the study of permutations and their algebras, which can be exemplified by the moves and configurations of a Rubik’s cube. With this machinery, we’ll define the homology groups of a topological space, in which holes live, and are one of the most important and studied topological invariants of spaces.">
  <meta itemprop="datePublished" content="2025-01-14T12:33:23-03:00">
  <meta itemprop="dateModified" content="2025-01-14T12:33:23-03:00">
  <meta itemprop="wordCount" content="16070">
  <meta itemprop="image" content="http://localhost:1313/images/share.png">
  <meta itemprop="keywords" content="Topology for Artists">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
      --width: 800px;
      --font-main: Verdana, sans-serif;
      --font-secondary: Verdana, sans-serif;
      --font-scale: 1em;
      --background-color: #fff;
      --heading-color: #222;
      --text-color: #444;
      --link-color: #3273dc;
      --visited-color:  #8b6fcb;
      --code-background-color: #f2f2f2;
      --code-color: #222;
      --blockquote-color: #222;
  }

  @media (prefers-color-scheme: dark) {
      :root {
          --background-color: #333;
          --heading-color: #eee;
          --text-color: #ddd;
          --link-color: #8cc2dd;
          --visited-color:  #8b6fcb;
          --code-background-color: #777;
          --code-color: #ddd;
          --blockquote-color: #ccc;
      }
  }

  body {
      font-family: var(--font-secondary);
      font-size: var(--font-scale);
      margin: auto;
      padding: 20px;
      max-width: var(--width);
      text-align: left;
      background-color: var(--background-color);
      word-wrap: break-word;
      overflow-wrap: break-word;
      line-height: 1.5;
      color: var(--text-color);
  }

  h1, h2, h3, h4, h5, h6 {
      font-family: var(--font-main);
      color: var(--heading-color);
  }

  a {
      color: var(--link-color);
      cursor: pointer;
      text-decoration: none;
  }

  a:hover {
      text-decoration: underline; 
  }

  nav a {
      margin-right: 8px;
  }

  strong, b {
      color: var(--heading-color);
  }

  button {
      margin: 0;
      cursor: pointer;
  }

  main {
      line-height: 1.6;
  }

  table {
      width: 100%;
  }

  hr {
      border: 0;
      border-top: 1px dashed;
  }

  img {
      max-width: 100%;
  }

  code {
      font-family: monospace;
      padding: 2px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
  }

  blockquote {
      border-left: 1px solid #999;
      color: var(--code-color);
      padding-left: 20px;
      font-style: italic;
  }

  footer {
      padding: 25px 0;
      text-align: center;
  }

  .title:hover {
      text-decoration: none;
  }

  .title h1 {
      font-size: 1.5em;
  }

  .inline {
      width: auto !important;
  }

  .highlight, .code {
      padding: 1px 15px;
      background-color: var(--code-background-color);
      color: var(--code-color);
      border-radius: 3px;
      margin-block-start: 1em;
      margin-block-end: 1em;
      overflow-x: auto;
  }

   
  ul.blog-posts {
      list-style-type: none;
      padding: unset;
  }

  ul.blog-posts li {
      display: flex;
  }

  ul.blog-posts li span {
      flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
      color: var(--visited-color);
  }
</style>


    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']],                  
      macros :{
        im : "{\\text{im}\\,}",
        os : "[v_0,v_1]", 
        ts : "[v_0,v_1,v_2]", 
        ths : "[v_0,v_1,v_2,v_3]", 
        gos : "\\langle v_0, v_1 \\rangle", 
        gts : "\\langle v_0, v_1, v_2 \\rangle", 
        gths : "\\langle v_0, v_1, v_2, v_3 \\rangle", 
        rth : "\\mathbb{R}^3", 
        rt : "\\mathbb{R}^2", 
        ro : "\\mathbb{R}", 
        rpt : "\\ro \\text{P}^2", 
        rpth : "\\ro \\text{P}^3", 
        rn : "\\mathbb{R}^n",
        rpn : "\\mathbb{R}\\text{P}^n",
        angled : ["{\\langle #1 \\rangle}", 1],
        zo : "\\mathbb{Z}",
        zmod : ["\\mathbb{Z}/#1 \\mathbb{Z}", 1],
        inv : ["#1 ^{-1}", 1],
        cdn : ["C^\\Delta_#1", 1],
        csn : ["C^s_#1", 1],
        rank : ["\\text{rank}\\,\\,\\,"],
        pard : ["\\frac{\\partial #1}{\\partial #2}", 2] 
      }
    }
  };
</script>
  
</head>

<script type="text/javascript" src="/js/GlslCanvas.js"></script>

<body>
  <header><a href="/" class="title">
  <h2>Topophilic</h2>
</a>
<nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  
  <main>

<h1>Algebraic topology for game dev: 3D graphics and winning flows</h1>
<p>
  <i>
    <time datetime='2025-01-14'>
      14 Jan, 2025
    </time>
  </i>
</p>


<h1 id="tldr">TL;DR</h1>
<p>In our search for topological invariants, we&rsquo;ll learn how <strong>holes</strong> can be defined and be used to study spaces. This will require studying &ldquo;model&rdquo; spaces, known as simplicial complexes, which are widely used in <strong>3D rendering</strong>. We will be able to define general topological concepts like &ldquo;<em>boundary</em>&rdquo; and &ldquo;<em>cycle</em>&rdquo;. This will be formalized through a quick detour on <strong>group theory</strong>, the study of permutations and their algebras, which can be exemplified by the <em>moves and configurations</em> of a <strong>Rubik&rsquo;s cube</strong>. With this machinery, we&rsquo;ll define the <strong>homology groups</strong> of a topological space, in which holes live, and are one of the most important and studied <em>topological invariants</em> of spaces.</p>

    <aside id="TableOfContents">
        <nav id="TableOfContents">
  <ol>
    <li><a href="#tldr">TL;DR</a></li>
    <li><a href="#what-youll-need">What you&rsquo;ll need</a></li>
    <li><a href="#introduction-and-intuition">Introduction and intuition</a></li>
    <li><a href="#simplices-and-topology">Simplices and topology</a>
      <ol>
        <li><a href="#n-simplices-and-complexes">N-simplices and complexes</a></li>
        <li><a href="#surfaces-from-squares">Surfaces from squares</a>
          <ol>
            <li><a href="#the-cylinder">The cylinder</a></li>
            <li><a href="#the-torus">The torus</a></li>
            <li><a href="#the-sphere">The sphere</a></li>
            <li><a href="#the-möbius-strip">The Möbius strip</a></li>
            <li><a href="#the-klein-bottle">The Klein bottle</a></li>
            <li><a href="#projective-spaces-perspective-and-homogenous-coordinates-">Projective spaces: perspective and homogenous coordinates *</a></li>
            <li><a href="#connecting-surfaces-together">Connecting surfaces together</a></li>
          </ol>
        </li>
        <li><a href="#delta-spaces">Delta spaces</a></li>
      </ol>
    </li>
    <li><a href="#3d-graphics-and-the-algebra-of-holes">3D graphics and the algebra of holes</a>
      <ol>
        <li><a href="#meshes-and-simplices">Meshes and simplices</a></li>
        <li><a href="#orientations-and-boundaries">Orientations and boundaries</a></li>
        <li><a href="#doing-algebra-with-faces">Doing algebra with faces</a></li>
        <li><a href="#the-case-of-delta-spaces">The case of delta spaces</a></li>
        <li><a href="#cycles-and-holes">Cycles and holes</a></li>
      </ol>
    </li>
    <li><a href="#homology-theory">Homology theory</a>
      <ol>
        <li><a href="#homology-groups">Homology groups</a></li>
        <li><a href="#holes-of-dimension-0">Holes of dimension 0</a></li>
        <li><a href="#disks">Disks</a></li>
        <li><a href="#the-circle-and-the-spheres">The circle and the spheres</a></li>
        <li><a href="#the-torus-1">The torus</a></li>
        <li><a href="#the-klein-bottle-1">The Klein bottle</a></li>
        <li><a href="#the-projective-plane">The projective plane</a></li>
        <li><a href="#invariance-of-the-euler-characteristic">Invariance of the Euler characteristic</a></li>
        <li><a href="#holes-of-order-2-">Holes of order 2 *</a></li>
        <li><a href="#homology-with-coefficients">Homology with coefficients</a></li>
      </ol>
    </li>
    <li><a href="#applications">Applications</a>
      <ol>
        <li><a href="#functors-retractions-and-fixed-points">Functors, retractions and fixed points</a></li>
        <li><a href="#the-hex-game">The Hex game</a></li>
      </ol>
    </li>
    <li><a href="#going-further">Going further</a>
      <ol>
        <li><a href="#homotopy-invariance-of-homology">Homotopy invariance of homology</a></li>
        <li><a href="#long-exact-sequences-excision">Long exact sequences, excision</a></li>
        <li><a href="#isomorphism-of-simplicial-delta-and-singular-homologies">Isomorphism of simplicial, delta and singular homologies</a></li>
        <li><a href="#cw-complexes-and-cellular-homology">CW complexes and cellular homology</a></li>
      </ol>
    </li>
  </ol>
</nav>
    </aside>

<div class="webgl-player">
	<div id="jonas-unity-browser-width-warning" class="unity-browser-width-warning">
		
	</div>
	<div id="jonas-unity-mobile-warning" class="unity-mobile-warning">
		
	</div>
	<div id="jonas-unity-container" class="unity-container unity-desktop" style="width: 800px;">
		<canvas id="jonas-unity-canvas" class="unity-canvas" width=800 height=600></canvas>
		<button id="jonas-unity-load-button" class="unity-load-button">start loading</button>
		<div id="jonas-unity-loading-bar" class="unity-loading-bar">
			<div id="jonas-unity-progress-bar-empty" class="unity-progress-bar-empty">
				<div id="jonas-unity-progress-bar-full" class="unity-progress-bar-full"></div>
			</div>
		</div>
		<div id="jonas-unity-footer" class="unity-footer">
			<div id="jonas-unity-fullscreen-button" class="unity-fullscreen-button"></div>
			<div id="jonas-unity-game-title" class="unity-game-title">Build 001</div>
		</div>
		<script>
			var buildUrljonas = "/unity_builds/b1/Build";
			var loaderUrljonas = buildUrljonas + "/WebGL_Build.loader.js";
			var configjonas = {
				dataUrl: buildUrljonas + "/WebGL_Build.data",
				frameworkUrl: buildUrljonas + "/WebGL_Build.framework.js",
				codeUrl: buildUrljonas + "/WebGL_Build.wasm",
				streamingAssetsUrl: "StreamingAssets",
			};

            var containerjonas = document.querySelector("#jonas-unity-container");
			var canvasjonas = document.querySelector("#jonas-unity-canvas");
			var loadButtonjonas = document.querySelector("#jonas-unity-load-button");
			var loadingBarjonas = document.querySelector("#jonas-unity-loading-bar");
			var progressBarFulljonas = document.querySelector("#jonas-unity-progress-bar-full");
			var fullscreenButtonjonas = document.querySelector("#jonas-unity-fullscreen-button");
			var mobileWarningjonas = document.querySelector("#jonas-unity-mobile-warning");

			
			
			
			
			
			

			if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
				mobileWarningjonas.style.display = "block";
			} else {
				mobileWarningjonas.style.display = "none";
			}
			canvasjonas.style.width = "800px";
			canvasjonas.style.height = "600px";
			loadingBarjonas.style.display = "none";

			var scriptjonas = document.createElement("script");
			scriptjonas.src = loaderUrljonas;
			loadButtonjonas.addEventListener("click", function () {
				createUnityInstance(canvasjonas, configjonas, (progress) => {
					progressBarFulljonas.style.width = 100 * progress + "%";
				}).then((unityInstance) => {
					loadingBarjonas.style.display = "none";
					loadButtonjonas.style.display = "none";
					loadButtonjonas.disabled = true;
					fullscreenButtonjonas.onclick = () => {
						unityInstance.SetFullscreen(1);
					};
				}).catch((message) => {
					alert(message);
				});
			});
			loadButtonjonas.addEventListener("click", function () {
				loadButtonjonas.disabled = true;
				loadingBarjonas.style.display = "block";
			});
			document.body.appendChild(scriptjonas);
		</script>
	</div>
</div>
<p><canvas id="shader-canvas-0"></canvas>
<script>
  (function() {
    async function loadShaderFile(url) {
    const response = await fetch(url);
    return response.text();
}
    async function doWebGL(){
    const canvas = document.getElementById("shader-canvas-0");
    const gl = canvas.getContext("webgl2");
    

  canvas.width = 800;
  canvas.height = 600;
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

  const vsSource = `#version 300 es
  in vec4 a_position;
  void main() {
    gl_Position = a_position;
  }`;

  const fsSource = await loadShaderFile("/shaders/raster.glsl");

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  function createProgram(gl, vsSource, fsSource) {
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
      return null;
    }
    return program;
  }

  const program = createProgram(gl, vsSource, fsSource);
  const uFragCoordLocation = gl.getUniformLocation(program, "u_resolution");
const uTimeLocation = gl.getUniformLocation(program, "u_time");
const uMouseLocation = gl.getUniformLocation(program, "u_mouse");

gl.useProgram(program);
gl.uniform2f(uFragCoordLocation, canvas.width, canvas.height);

let mouseX = 0.0, mouseY = 0.0;
let isMouseDown = false;
let mouseSensitivity = 1000.0;

canvas.addEventListener("mousedown", (event) => {
    isMouseDown = true;
});


canvas.addEventListener("mouseup", (event) => {
    isMouseDown = false;
});


canvas.addEventListener("mousemove", (event) => {
    if (isMouseDown) {
        const rect = canvas.getBoundingClientRect();
        mouseX = (event.clientX - rect.left) / canvas.width;
        mouseY = 1.0 - (event.clientY - rect.top) / canvas.height; 
        
    }
});

function render(time) {
    gl.useProgram(program);
    gl.uniform1f(uTimeLocation, time * 0.001);
    gl.uniform2f(uMouseLocation, mouseSensitivity * mouseX, mouseSensitivity * mouseY);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
}
requestAnimationFrame(render);




  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,  1, -1, -1,  1,  
    -1,  1,  1, -1,  1,  1
  ]), gl.STATIC_DRAW);

  const positionLocation = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  }
  doWebGL();}
  )();
</script>

!!! - to do
??? - to explain</p>
<figure style="display: flex; flex-direction: column; align-items: center; text-align: center; margin: 0 auto;">
    <img 
        src="flagellation.jpg" 
        alt="" 
        style="max-width: 100%; height: auto;"
    >
    
        <figcaption style="margin-top: 0.5rem; font-style: italic;">
            <em>Flagellation</em> of Christ, by <strong>Piero</strong> della Francesca.
        </figcaption>
    
</figure>

<figure style="display: flex; flex-direction: column; align-items: center; text-align: center; margin: 0 auto;">
    <img 
        src="anamorphic.jpg" 
        alt="" 
        style="max-width: 100%; height: auto;"
    >
    
        <figcaption style="margin-top: 0.5rem; font-style: italic;">
            <em>Flagellation</em> of Christ, by <strong>Piero</strong> della Francesca.
        </figcaption>
    
</figure>


<iframe
    src="//www.shadertoy.com/embed/DlffR8"
    title="ShaderToy Shader"
    height="500"
    frameborder="0"
    marginwidth="0"
    marginheight="0"
    scrolling="no"
    style="box-shadow: 0px 5px 10px rgb(0, 175, 255); margin-bottom: 10px; margin-top: 10px; width: 100%;"
    allowfullscreen="true">
</iframe>
<figcaption style="text-align: center">oiiii</figcaption>

<p>TODO:
TRIANG CILINDRO
melhorar parte de complexos
3d: setup geral de 3d render, melhorar explicac dos algoritmos (CORREC: depth é do pixel, n do triangulo. precisa melhorar bastante ambas as explicacs), iluminac e orientac. Usar imgs e shaders. Orientac das edges tbm!
delta spaces: corrigir e revisar
#deixar claro q orientac é prop topológica já no início!
MESHES N SÃO 2-SIMPLEXOS (EG TRIANGS INTERSECTANDO), MAS BASEADOS E REDUTÍVEIS A ESTES</p>
<p>TODO:Corrigir estrutura de simplexo do círculo. Dar exemplo do disco.</p>
<p>Delta sets tem q FILL o espaço (td ponto no interior de algm)</p>
<p>ALG LIN:
matrizes OK
tipos de coisas q são trans lins, TRANSLAC NÃO É OK
Distância euclidiana $d(a,b)$, norma e normalizac OK
dot e exterior products (matrizes tbm?) OK</p>
<p>ÁLGEBRA N É PRA SER EXPERIMENTO OU SURPRESINHA, MAS ALGO Q SURGE PRA SOLUCIONAR E JUNTAR TUDO NUM MESMO ESPAÇO!!!</p>
<p><strong>NA INTRO, DAR + EXEMPLOS DE CASOS PERFEITOS: EG, S1 1 CICLO 1D, TORO 1 2D, 2 1D, ETC. VERY IMPORTANT!!!</strong></p>
<h1 id="what-youll-need">What you&rsquo;ll need</h1>
<p>Before the section <strong>&ldquo;Homology theory&rdquo;</strong>, you&rsquo;ll need the following sections from other posts:</p>
<ul>
<li>Introduction:
<ul>
<li>Metric and topological spaces:
<ul>
<li>Topological spaces;</li>
<li>Some common topologies;</li>
<li>Continuity, homeomorphisms;</li>
<li>Homotopy.</li>
</ul>
</li>
</ul>
</li>
<li>Algebra:
<ul>
<li>Basic linear algebra.</li>
</ul>
</li>
</ul>
<p>From the section <strong>&ldquo;Homology theory&rdquo;</strong> on, you&rsquo;ll need:</p>
<ul>
<li>Algebra:
<ul>
<li>Groups, permutations and their games:
<ul>
<li>Definitions and basic examples;</li>
<li>Describing groups;</li>
<li>Generating groups;</li>
<li>Example: rings and modules;</li>
<li>Group quotients.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="introduction-and-intuition">Introduction and intuition</h1>
<p>This post will connect many different topics, but let us begin straight away with a question of topological character: what is a hole? How many holes does a space have?</p>
<p>See, if topology is rubbersheet geometry&ndash; where things can be seen as equivalent whenever you can transform one into another continuously, without gluing or cutting&ndash;, then it should be intuitive that &ldquo;holes&rdquo; could lead us to topological invariants. You can&rsquo;t, for example, turn a circle into a disk or into a line without cutting it or gluing stuff to it. Equally, a hollow sphere can&rsquo;t be turned homeomorphically to a plane or something similar. Holes are getting in the way of such transformations. This visually makes sense, but how to actually &ldquo;compute&rdquo; the holes of a space? This is the main theoretical purpose of this post: developing a theory of holes mathematicians call <strong>homology theory</strong>, which uses notions from topology, geometry and algebra.</p>
<p>First note that there is a dimensionality factor when we talk about what we intuitively call a hole. For 1D spaces (lines, circles, segments, graphics, etc.), we&rsquo;re thinking about a loop&ndash; a path that ends where it begins. Not only that, but a loop which has &ldquo;no interior&rdquo; filling its inside. For 2D spaces (planes, spheres, surfaces like the torus, etc.), having a hole means they&rsquo;re &ldquo;hollow&rdquo;, in the sense they&rsquo;re surfaces without a border and &ldquo;not filled&rdquo;. This means that <strong>each dimension has a unique notion of &ldquo;n-dimensional hole&rdquo;</strong>, and  we&rsquo;ll find these all have something in common.</p>
<p>Both for 1D and 2D holes, there are two intuitive ideas in play. First, holes should represent shapes that are &ldquo;closed into themselves&rdquo;, that are &ldquo;cycles&rdquo; in the sense they have no border&ndash; that an ant can transverse them forever, and never fall off. They are also &ldquo;unfilled&rdquo;, there&rsquo;s nothing &ldquo;inside them&rdquo;&ndash; or, rather, they aren&rsquo;t the boundary of some filling matter. Both of these conditions are neccessary. For example, if we take the boundary circle of a disk by itself, it is indeed a loop, a cycle. But it is also filled by the content of the disk, being its boundary&ndash; so there&rsquo;s no hole. On the other hand, a circle has a hole since it is a non-boundary cycle.</p>
<p>IMG!!! (S1 E D2)</p>
<p>I.e., holes are represented by cycles that aren&rsquo;t filled. When a subspace is a boundary of another one, we say it is <strong>bounded</strong>. Thus, holes are represented by <strong>boundaryless, non-bounded subspaces</strong>.</p>
<p>Imagine we have a surface&ndash; say, a cylinder&ndash; and want to find 1D holes in it. We can try to see the different loops we can draw on this cylinder. Some of these loops are filled and can be continuously contracted inside the surface to a single point. These don&rsquo;t really tell us anything about holes. However, there is another class of loops that are not filled within the cylinder&ndash; those that &ldquo;go around it&rdquo;, so to speak. These all should represent the single hole in the cylinder!</p>
<p>IMG!!! (CILINDRO E CICLOS)</p>
<p>Similarly, take a 2D shape like a ring&ndash; i.e., a disk with a smaller disk cut out from it, like a DVD. We have a single hole in this space. Consider the two circles that compose the boundary of this shape. Both are cycles. None of them are the complete boundary of some subspace, indicating they&rsquo;re also unfilled. They should be seen as representing the hole we made&ndash; and the same can be said about all the loops in between them! Note that this is all because of the puncture we introduced in the original disk, otherwise all these loops would be boundaries.</p>
<p>IMG!!! (RING)</p>
<p>This could be perfected, though. See, in both examples above, we have a single hole, but infinitely many non-boundary cycles representing it. This seems a little awkward. Thankfully, all these cycles have something in common: whevener you pick two of them, they form the complete border of a surface (in the first case, of a &ldquo;mini-cylinder&rdquo;, in the second of a &ldquo;mini-ring&rdquo; contained in the original space).</p>
<p>IMG!!! (acima)</p>
<p>This leads us to think of holes as actually <strong>classes of non-boundary cycles</strong>, two cycles being on the same class if they together form the boundary of some space of one dimension above&ndash; so to speak, if they are &ldquo;connected&rdquo;, or &ldquo;joined&rdquo; by that subspace.</p>
<p>So that we&rsquo;re all on the same page, here are some examples of what we expect to get as the holes of some spaces:</p>
<ul>
<li>
<p>Circle $S^1$: the prototypical loop, it only has one 1-dimensional hole;</p>
</li>
<li>
<p>Disk $D^2$: the prototypical filled loop, it has many 1D cycles, but all bounded&ndash; thus no holes;</p>
</li>
<li>
<p>Cylinder $S^1\times [0,1]$: similarly to the circle, only one 1D hole;</p>
</li>
<li>
<p>Sphere $S^2$: the prototypical hollow surface, it only has one 2D hole;</p>
</li>
<li>
<p>Torus $T^2$: it has one single 2D hole, representing its entire, hollow surface. It also has two 1D ones: one &ldquo;transversal&rdquo; (around the whole doughnut), one &ldquo;longidutinal&rdquo; (around the tube made by the torus);</p>
</li>
<li>
<p>The reals $\mathbb{R}^n$: lines, planes and their higher-dimensional generalizations are all convex, so should have no holes at all.</p>
</li>
</ul>
<p>IMGS!!! (cylinder?, torus)</p>
<p>Most of this post will deal with the non-trivial, although highly enriching proccess of formalizing these inutitive notions.</p>
<h1 id="simplices-and-topology">Simplices and topology</h1>
<h2 id="n-simplices-and-complexes">N-simplices and complexes</h2>
<p>In order to compute holes, we&rsquo;ll first approximate our spaces using simpler ones&ndash; specifically, polygons&ndash; that will allow for concrete computations. The building blocks of these approximations are called <strong>n-simplices</strong>. Formally, a n-dimensional simplex is defined as the convex hull of $n+1$ points $v_0,...,v_n$ such that the vectors $v_i-v_j$ are all linearly independent, for all distinct pairs $i,j.$</p>
<p>For example, for a 1-simplex, we take two different points $v_0, v_1,$ and then fill the segment $[v_0, v_1],$ getting a line betwen $v_0, v_1:$ a 1-simplex is a straight line. For a 2-simplex, we take three points $ v_0, v_1, v_2$ satisfying $v_1 - v_0,$ $v_2-v_0$ and $v_2-v_1$ being non-colinear: the 2-simplex will be the (filled) triangle with them as vertices. Similarly, a 3-simplex is a (filled) pyramid with vertices $v_0,v_1,v_2,v_3$ (assuming these points satisfy the l.i. condition in the definition). That is, <strong>simplices are generalization of polygons</strong>.</p>
<p>IMG!!! simplices</p>
<p>The condition that all $v_i-v_j$ should be l.i. guarantees the &ldquo;faces&rdquo; of our polygon won&rsquo;t glue to each other: if we had, say, $v_0=(0,0), v_1=(1, 1), v_2=(2,2),$ $v_2-v_0=v_2$ and $v_1-v_0=v_1$ being colinear, the hull of these points would just be a line from $v_0$ to $v_2$, which isn&rsquo;t a 2-simplex, a triangle&ndash; or rather, it is a triangle with glued, &ldquo;degenerate&rdquo; edges. When the points don&rsquo;t satisfy the mentioned l.i. condition we can talk about a &ldquo;degenerate simplex&rdquo;, which we&rsquo;ll not study here.</p>
<p>The condition that all $v_i-v_j$ for $i\neq j$ be l.i. is actually equivalent to asking $v_i-v_0$ to be l.i. for $i>0.$ Proving this a simple linear algebra exercise.</p>
<p>Also, note that 0-simplices are just points, the l.i. condition being &ldquo;nully satisfied&rdquo; (there are no vectors $v_i-v_0$ for $i>0$!), with $\angled{v_0}$ being exactly the set $\{v_0\}$.</p>
<p>Since an n-simplex is completely determined by its $n+1$ points $v_0,...,v_n$ (as the hull is unique), we&rsquo;ll denote it as $\angled{v_0,...,v_n}$. For now, the order you put these points in the presentation doesn&rsquo;t matter- but soon it will.</p>
<p>By the expression we found for convex hulls, each element $p$ of an n-simplex $\angled{v_0,...,v_n}$ is of the form $\lambda_0 v_0+...+\lambda_n v_n$, with $\sum \lambda_i=1$ and $\lambda_i\geq 0$ for all $i$. These $\lambda_i$ can be interpreted as &ldquo;simplicial coordinates&rdquo; of $p$ relative the base points. In the 2-simplex case, each element of the interior of the triangle is given an unique such coordinate in respect to the three vertices, known as its <strong>barycentric coordinate</strong>.</p>
<p>IMG!!! BARYCENTRIC</p>
<p>These coordinates are very important because they allow us to extend maps from the vertices $v_0,...,v_n$ to the whole simplex $\angled{v_0,...,v_n}$: if we have <strong>any</strong> function $f:\{v_0,...,v_n\}\rightarrow \mathbb{R}^k$, we can extend it to a linear (and thus <strong>continuous</strong>) map $\widehat{f}:\angled{v_0,...,v_n}\rightarrow \mathbb{R}^k$ by defining</p>
$$\widehat{f}(\lambda_0 v_0+...+\lambda_n v_n) = \lambda_0 f(v_0)+...+\lambda_n f(v_n),$$<p>so that, in particular, the image of $\widehat{f}$ is exactly the (possibly degenerate) n-simplex $\angled{f(v_0),...,f(v_n)}.$</p>
<p>For practicality, we also define the <strong>standard n-simplex</strong> $ \Delta^n$ to be the simplex with base points the origin $(0,...,0)$ and the canonical base vectors $e_1,...,e_n.$ By the formula for the convex hull we gave, $ \Delta^n=\{(\lambda_1,...,\lambda_n)\mid  \sum_{i=1}^n \lambda_i=1, \,\lambda_i\geq 0\}$. Every n-simplex is homeomorphic to $ \Delta^n$ by simple linear transformations of translation and stretching. Topologically, $\Delta^n$ is homeomorphic to $D^n$, and so is the case for all other n-simplices.</p>
<p>For a simplex $\angled{v_0,...,v_n}$, its <strong>faces</strong> are all the sub-simplices $\angled{v_0,...,\widehat{v_i}, ...,v_n}$, where this notation indicates that the vertex of index $0\leq i\leq n$ is ommited. For example, a 1-simplex $\gos$ has faces $\angled{v_1}$ and $\angled{v_0}$, its end and start points. For a 2-simplex, the faces of $\gts$ are $\angled{v_1, v_2}$, $\angled{v_0, v_2}$ and $\gos$, which in this case we can also call the edges of the 2-simplex. Finally, for the 3-simplex $\gths$, its faces are the triangles $\angled{v_1, v_2, v_3},$ $\angled{v_0, v_2, v_3},$ $\angled{v_0, v_1, v_3}$ and $\gts$, in which case the use of the term &ldquo;face&rdquo; is closer to the usual. For higher dimensions, the same formula for faces applies as well, even though we can&rsquo;t properly see these simplices.</p>
<p>We&rsquo;ll then call the <strong>boundary</strong> of a simplex to be the set</p>
$$\partial \angled{v_0,...,v_k} = \bigcup_{i=0}^n \angled{v_0,...,\widehat{v_i},...,v_k},$$<p>i.e., the union of its faces.</p>
<p>IMG!!! boundaries</p>
<p>The use of intuitive and familiar concepts (like of a face) and this recursive property of simplices&ndash; i.e., that they are made of smaller simplices themselves&ndash; are the main reasons why we will use these spaces in our computations.</p>
<p>Now, how can we use simplices to understand our spaces better? We&rsquo;ll discuss two ways: <strong>simplicial complexes</strong> and <strong>delta spaces</strong>. The first basically consists in gluing simplices together in order to approximate our space with a polygonal shape homeomorphic to it. Formally, a <em>simplicial complex</em> on $\mathbb{R}^n$ is a set of simplices $S=\{s_1,...,s_k\}$ of possibly different dimensions such that every face of $s_i$ is also in $S$ and so that if $s_1, s_2$ intersect, then their intersection is a common face between them. This means simplicial complexes are constructed by simplices through disjoint unions or gluing their faces together.</p>
<p>IMG!!! (complexos gerais)</p>
<p>For example, a square can be seen as a simplicial complex with two 2-simplices glued on a common edge, as below. These are usually called <strong>quads</strong>. If we use $\Delta^2$ and $\angled{(0, 1), (1, 1), (1, 0)}$ glued along the edge $\angled{(0, 1), (1, 0)}$ to form a quad, we&rsquo;ll call this simplex the &ldquo;<strong>standard quad</strong>&rdquo;.</p>
<p>IMG!!! (quad)</p>
<p>Another simple example of a complex is the boundary $\partial \angled{v_0,...,v_n}$ of a simplex. In the 2-simplex case, for example, this is the three edges of our triangle joined together at the vertices.</p>
<p>Indeed, many spaces of interest can be described as homeomorphic to a simplicial complex on $\mathbb{R}^n$, at least for a high enough $n$. When this is the case, we say our space is <strong>triangulable</strong>, since in the two-dimensional, surface case this is equivalent to dividing our embedded space into triangles. Generally, a <strong>triangulation</strong> of a space is a homeomorphic space to it which is a simplicial complex&ndash; i.e., it is a <strong>polygonal topological approximation</strong>, so to speak.</p>
<p>Let&rsquo;s see some examples of complexes homeomorphic to spaces of interest. First, the $\Delta^n$ themselves give us a simplicial model of $D^n$. For the n-dimensional sphere $S^n$, $\partial \Delta^{n+1}$ is a complex homeomorphic to it. In the case of the circle, this is just the three edges of a triangle.</p>
<p>IMG!!! (desengo dos espaços)</p>
<p>SHADER!!! (D3)</p>
<p>What about, say, a cylinder? This can be done by gluing three quads in sequence, and then gluing the first and last ones together as well, forming a &ldquo;triangular straw&rdquo;.</p>
<p>SHADER!!!</p>
<p>For the torus, this is a bit more intricate. First, form a skewed cylinder with two triangles as its boundary. Make three copies of this shape, and then glue them together in their boundaries and you&rsquo;ll get a torus, as shown below.</p>
<p>SHADER!!! (BARRA, TORO)</p>
<p>IMG!!!</p>
<p>Of course, all these shapes could be made with many more simplices, getting a better approximation of their idealized, curved versions. But this isn&rsquo;t topologically relevant (at least until we use calculus in algebraic topology, which isn&rsquo;t something we&rsquo;re goint to do in this post).</p>
<h2 id="surfaces-from-squares">Surfaces from squares</h2>
<p><strong>Note</strong>: in this section, we&rsquo;ll adopt the lazy topological convention of calling every rectangle a square.</p>
<h3 id="the-cylinder">The cylinder</h3>
<p>Schematically, we could represent the triangulation above of the cylinder we provided in a plain figure as below:</p>
<p>IMG!!! Triang do cilindro</p>
<p>Above, we have the three quads and the glued edges marked as the same one, called $a$. We give a direction to these edges in order to denote where we should join their vertices: their end points should be glued together, as should the starting ones (&ldquo;end on end, start on start&rdquo;). That is, we glue $v_0$ to $v_6$ and $v_2$ to $v_7$, so that these will be identified in the cylinder. This is not the only way to paste the edges $\angled{v_0, v_1}$ and $\angled{v_6, v_7}$ together, though. We could instead decide to do a &ldquo;twist&rdquo; and identify $v_0$ with $v_7$ and $v_2$ with $v_6$&ndash; a case which we&rsquo;ll consider soon.</p>
<p>That is: we represented a triangulation of the cylinder drawing some quads and then indicating how to glue edges, according to some direction. Note that this is just a way of representing our triangulation, not the triangulation per se, specially because there&rsquo;s no concrete indication of which points the vertices are.</p>
<p>Topologically, this means we can obtain a cylinder from a square by gluing two of its faces as done above. This works even without using simplices, so we get the following representation of a cylinder:</p>
<p>IMG!!!</p>
<p>This actually gives a <strong>general way of forming surfaces</strong>. You begin with a square, then label its edges and glue them respecting their start and end points as marked. You can try to replicate this with a sheet of paper. Let&rsquo;s dive a little deeper into that construction.</p>
<h3 id="the-torus">The torus</h3>
<p>We can get a similar plane representation for the triangulation of the torus we used before. First, take one of the skewed cylinders and cut it along one edge joining its two boundary triangles, making a flat piece as shown below. The edges marked as &ldquo;a&rdquo; indicate that they should be glued together, according to the given direction (&ldquo;end on end, start on start&rdquo;). Then we join three of these representations in sequence, gluing along the adequate edges. We also mark with &ldquo;b&rdquo; the edges that should be finally glued together to form the complete torus.</p>
<p>IMG!!! (flat piece, glued)</p>
<p>For schematic purposes, we can further simplify this figure flattening it to a square, getting the following representation:</p>
<p>IMG!!! (full triang)</p>
<p>Similarly to the cylinder, this means we can get the torus as given by the figure below: join two edges to form a cylinder. The other two edges are now cycles, and to form a torus all you have is to glue them as well.</p>
<p>IMG!!!</p>
<p>By the vertex labels, we can clearly see that $a$ and $b$ correspond to two loops on $T^2$&ndash; one longidutinal and one transversal, as we&rsquo;d expect.</p>
<h3 id="the-sphere">The sphere</h3>
<p>As we&rsquo;ve seen, $\Delta^3$ is a triangulation of $S^2$&ndash; and so is any pyramid. To get something similar as we got for the cylinder and the torus, take a pyramid and cut the edges connecting triangles above the base, getting this figure:</p>
<p>IMG!!! (RECORTADO)</p>
<p>Then, continuously deform this into a square:</p>
<p>IMG!!! (QUADRADO)</p>
<p>Finally, glue the $c$ edges together, to get this indication of how to topologically get $S^2$ from a square:</p>
<p>IMG!!! (FINAL)</p>
<p>You can try this on a sheet of paper, and see that it forms a closed cone&ndash; which is homeomorphic to a sphere!</p>
<h3 id="the-möbius-strip">The Möbius strip</h3>
<p>Another very interesting shape we can get this way is the <strong>Möbius strip</strong>. You leave the north and south edges alone, and joing the west and east ones&ndash; but with a twist, as we mentioned on the cylinder case:</p>
<p>IMG!!! (SQUARE, TRIANG)</p>
<p>SHADER!!!(MOBIUS)</p>
<p>The Möbius strip is the simplest example of a <strong>non-orientable space</strong>, specifically a non-orientable surface with boundary. This means you can&rsquo;t define what is &ldquo;inside&rdquo; or &ldquo;outside&rdquo; it: try pointing your finger towards a direction you think is outwards from the surface, and then follow the strip until you come back to the same point. Your finger will now point to the opposite direction! I.e., you can&rsquo;t define a cohesive notion of outside-ness within the strip.</p>
<p>GIF!!!!</p>
<p>More formally, we can&rsquo;t define coherently a <strong>normal vector</strong> for each point in the strip. A normal vector is a vector perpendicular to a point in a specified surface. Spaces with this property are called non-orientable, and those in which you can define coherent normal vectors for all points are called orientable. Indeed, orientability is a <strong>topological</strong> property: it doesn&rsquo;t how much you strecth an (non)orientable, it will always remain (non)orientable. Spheres, tori and disks, for example, are all orientable.</p>
<p>Similarly, if an ant transverses the strip in one direction, when it comes back to its initial position it will be facing the opposite direction from the beginning! You can&rsquo;t define inside and outside, nor can you define a cohesive transversing direction! Mathematically, this has to do with how we get normals from tangent vectors to a surface by doing the cross product&ndash; something that will be a bit clearer later.</p>
<p>The Möbius strip is a very alusive shape, and has inspired many artists and thinkers as a powerful metaphor. The whole world is outside and inside it, so to speak. It is a truly hegelian shape in this sense, a pure form that unifies object and subject, in and out, consciousness and self-consciousness. But let&rsquo;s leave its philosophy for another post of its own.</p>
<p>IMG!!! (obra do MAC)</p>
<p>Note also that the strip has a boundary homeomorphic to a circle. You can check this in the square representation by noting that the north and south edges have their end points glued together forming this cycle boundary. This circle geometrically performs a twist&ndash; a fact that might not seem particularly relevant here, but actually has quite deep connections to other topics in topology.</p>
<p>IMG!!! BOUNDARY</p>
<h3 id="the-klein-bottle">The Klein bottle</h3>
<p>What happens if we glue the Möbius strip boundary? Again, using the square representation, there are two ways: joining the remaining edges with and without a twist. When we do so without one, we get a space called the <strong>Klein bottle</strong>, which also has been an object of interest by many mathematicians and math-entusiasts alike. This is also a non-orientable space, but <strong>non-embeddable</strong> in $\rth$: that it is, it can&rsquo;t be properly seen in 3D space, it can&rsquo;t be properly described as a subspace of $\rth$. So don&rsquo;t try to phisically get it from a Möbius strip&ndash; it&rsquo;s impossible to do so in 3D space!</p>
<p>This is similar, say, to how $S^2$ can&rsquo;t be embedded in $\rt$&ndash; i.e., you can&rsquo;t properly have the sphere as a subspace of the plane. If you really wanted to fit it into the plane, you&rsquo;d have to glue some points together, mapping them to the same 2D point. The same happens with the Klein bottle. You might have seen the image below, which is meant to represent the bottle. It isn&rsquo;t the bottle per se: it is a representation in which the some of its points are glued in order to force it to be able to be seen in 3D space. This doesn&rsquo;t mean this is a bad or meaningless way to see the Klein bottle: quite on the contrary, we can use it, for example, to see that it isn&rsquo;t orientable, as the image below shows:</p>
<p>IMG!!! rep square, img mostrando n orient</p>
<p>Generally, when it is possible to describe a space $X$ as homeomorphic to a subspace inside some $Y$, we say it is <strong>embeddable</strong> in $Y$. Here, we&rsquo;ll only consider embeddability inside the reals $\ro^n$.</p>
<h3 id="projective-spaces-perspective-and-homogenous-coordinates-">Projective spaces: perspective and homogenous coordinates *</h3>
<p>There are two other interesting surfaces we can form in this manner which we will use as examples. The first one is the known as the <strong>real projective plane</strong> $\rpt$. It is a space that formalizes the notion of visual perspective, as understood for example in painting and design. Human vision interprets parallel lines as going closer at greater distances, tending to a &ldquo;vanish point&rdquo; where they meet. They never arrive this point: only &ldquo;at infinity&rdquo; do they do so.</p>
<p>We may formalize this as following. Take the human eye as a point $E$ in 3D space&ndash; we&rsquo;ll assume it is in the origin of our coordinate system. Light rays are arriving in this point from all directions. The 2D image the eye sees can be modeled as a plane $V$ lying exactly in front of the eye, the &ldquo;vision plane&rdquo;. Generally, we set $V$ to be the plane $z=1$. The color associated with each point within the plane is the color of the real-world object the ray going from the eye to the point eventually hits.</p>
<p>This model is widely used in computer graphics for projecting 3D scenes into a 2D rendered image. It&rsquo;s also basically identical to the more mature methods developed during the Renaissance for drawing and painting with perspective. The image below by Dürer, for example, represents one of these methods: a line was connected between a fixed point $E$ in the wall (representing our eye/camera) and a point $P$ lying on object. This line passed through a square frame, and the position the line passed through the frame was then marked on paper. This marked point represented the correct perspective position of $P$ on $E$&rsquo;s vision.</p>
<p>IMG!!! moderno</p>
<figure style="display: flex; flex-direction: column; align-items: center; text-align: center; margin: 0 auto;">
    <img 
        src="durerPerspec.jpg" 
        alt="" 
        style="max-width: 100%; height: auto;"
    >
    
        <figcaption style="margin-top: 0.5rem; font-style: italic;">
            <em>The Draughtsman of the Lute</em>, woodcut by Albrecht Dürer.
        </figcaption>
    
</figure>

<p>In this model, real-world lines are thus associated to a sequence of rays, each one going from $E$ to a point in the line. These rays intersect the vision plane at a unique point. When we have two real-world parallel lines, these give rise to two sequences of rays, which both tend to a single ray parallel to the vision plane. This represents exactly the phenomenom of vanishing points, with this parallel ray representing a &ldquo;point at infinity&rdquo; at which lines meet.</p>
<p>!!!IMG?</p>
<p>This prompts us to define the real projective plane $\rpt$ as the space of lines passing through the origin in 3D space- i.e., of 1D subspaces of $\rth$&ndash;, with an adequate topology we&rsquo;ll omit here. Lines parallel to the vision plane represent vanishing points, while those that intersect it represent visible ones. That is, this is the space where we can do <strong>projective geometry</strong>, the geometry of perspective and human vision. Similarly, we can define the projective space $\ro\text{P}^n$ of dimension $n$ to be the space of 1D subspaces of $\mathbb{R}^n$. Substituting $\mathbb{R}^n$ by any other vector space $V$, we also can define the projective space $\mathbb{P}(V)$ in the exact same way. We&rsquo;ll come back to these abstract projective spaces later.</p>
<p>Insted of dealing with lines, we could instead take $\rpt$ as $\rth-\{0\}$ and with points $p$ and $q$ being identified, seen as the same, whenever they lie on the same 1D subspace, i.e., if $p = \lambda q$ for a non-zero real $\lambda$. Each $p$ is taken to represent a line going from the origin to it. 3D points treated like this are said to be in 2D <strong>homogenous coordinates</strong>. As described above, every point in 2D cartesian coordinates $(x,y)$ has an associated point in homogenous coordinates, namely $(x,y,1)$, representing the line intersecting the plane $V$ in this position. Points in infinity are exactly those homogenous points that have $z$ coordinate equal to $0$, representing perpendicular lines to $V$. Every other homogenous points $(x, y, z)$ can be brought back to a cartesian $(x,y)$ by the equivalnce $(x, y, z) \sim (x/z, y/z, 1)$, giving a point in our vision plane $V$.</p>
<p>Generally, homogenous coordinates represent points of $\rpn$ by seeing lines as classes of points, two points $p,q$ being in the same class if they are colinear, giving $p=\lambda q$, $\lambda\neq 0$. We then can pass from cartesian to homogenous coordinates by the continuous function $f:\rn \rightarrow \rpn$ defined by $f(x_1,...,x_n)=(x_1,...,x_n,1)$. Conversely, if $(x_1,...,x_n,x_{n+1})$ has $x_{n+1}\neq 0$, we can go back to usual cartesian coordinates by dividing by $x_{n+1}$, getting the point $(x_1/x_{n+1},...,x_n/x_{n+1})$. In some sense, going from cartesian to homogenous coordinates gives a local parametrization of $\rpn$ by $\rn$&ndash; more technically, we have a homeomorphism $f:\rn \rightarrow \{(x_1,...,x_n,x_{n+1})\in\rpn \mid x_{n+1}\neq 0\}$ given by the $f$ above. Our decision to use the last coordinate was because we used the convention of the vision plane $V$ in $\rth$ as the plane $z=1$, but this isn&rsquo;t strictly neccesary. That is, we could define a whole set of local homeomorphisms $f_i:\rn \rightarrow \{(x_1,...,x_i, x_{n+1})\in\rpn \mid x_{i}\neq 0\}$ by $f_i(x_1,...,x_n)=(x_1,...,x_i,1,...,x_n)$, introducing an $1$ at the $(i+1)$-th coordinate. This way, we can actually cover $\rpn$ by the image of these functions, which are all homeomorphic to $\rn$.</p>
<p>We won&rsquo;t go much further on the considerations above, but these $f_i$ actually give a <strong>manifold</strong> structure on $\rpn$, a manifold being a space which is covered by homeomorphic copies of some $\rn$ for a fixed $n$. Most spaces we study here are manifolds: the sphere and the torus for example. Manifolds do not have boundaries. The Möbius band and all simplicial comlexes, on the other hand, are &ldquo;manifolds with boundaries&rdquo;: their &ldquo;interior&rdquo; is a manifold, but they also have a boundary of one dimension below.</p>
<p>Graphics programmers are probably familiar with homogenous coordinates, although for somewhat different reasons. They are widely used to transform objects in 3D scenes, specially because translations become linear transformations in these coordinates: more specifically, a translation by a vector $(t_1, t_2, t_3)$ can be given by the transformation $T(x, y, z, w)=(x + w * t_1, y + w * t_2, z + w * t_3, w)$, so that homogenous points $(x, y, z, 1)$ can be translated using $T$&ndash; while those at infinity of the form $(x, y, z, 0)$ are seen as merely giving direction, without further spacial content.</p>
<p>To see how $\rpt$ can be obtained from a square, note that if $S^2_N$ is the northern hemisphere of the sphere (counting the equator as well), then we have a continuous function $g:S^2_N \rightarrow \rpt$ sending each point in the hemisphere to the unique line passing through it. This is injective outside the equator (and topologically equivalent to the function $f$ described above relating to perspective), but inside it every point $p$ in the equator is mapped to the same line as its antipode $-p$&ndash; the point diametrically opposite to it. This means we can see $\rpt$ as a copy of $S^2_N$, but with antipodal points in the equator glued together. Homeomorphically turning $S^2_N$ into a square, this is exactly what the representation below does! Note that the original four vertices of the square became just two with the identifications we made.</p>
<p>IMG!!!</p>
<p>One very interesting way of getting $\rpt$ is through the Möbius strip. See, the latter has a boundary, which is a single loop. In the square representation, this loop is the non-glued horizontal edges. What if we glue them in opposite directions (i.e., again with a twist)? Well, the representation above just showed that we would get the projective plane! In particular, we also have that $\rpt$ isn&rsquo;t orientable.</p>
<p>Another interesting property of $\ro \text{P}^2$ is  NON EMBED</p>
<h3 id="connecting-surfaces-together">Connecting surfaces together</h3>
<p>This way of representing surfaces is so powerful that it actually allows us to generate all possible surfaces! This is done as follows.</p>
<p>Imagine you have two torii $T_1$ and $T_2$ and you want to join them in order to form a bitorus. One way to do so is to cut two disks on the surfaces of $T_1$ and $T_2,$ and then join them along the boundaries of these disks.</p>
<p>IMG!!!</p>
<p>Generally, if you have two surfaces $X$ and $Y$, you can do the same for them: take two disks $D^2$ (or, generally, subspaces homeomorphic to disks) inside $X$ and $Y$; then, join $X-D^2$ and $Y-D^2$ along their boundaries (both being homeomorphic to $S^1$). The obtained space is called the <strong>connected sum</strong> of $X$ and $Y$, denoted $X\# Y.$</p>
<p>Proving that this is a well-behaved operation between surfaces (including non-orientable ones!) is actually highly non-trivial, so we&rsquo;ll just use without proof that:</p>
<ul>
<li>
<p>$X\# Y$ is independent of the disks we choose;</p>
</li>
<li>
<p>$X \# Y = Y \# X.$</p>
</li>
</ul>
<p>You can use the square representations of surfaces to represent $X\# Y$ as well: just cut subspaces homeomorphic to disks inside each representation, and glue them according to the construction of $X\# Y.$</p>
<p>For example, we just saw that $T^2\# T^2$ is the bitorus: indeed, doing $T^2\#...\# T^2$ $n$ times gives the $n$-torus. For the bitorus, &hellip;</p>
<p>SHADER!!! bitorus</p>
<p>What about $S^2\# S^2$? Intuitively, this corresponds to joining two !!!. Using squares, we can describe it as following: take the representation of $S^2$ and</p>
<p>IMG!!!</p>
<p>RP RP = K</p>
<p>Now, $\rpt \# \rpt$ is a bit more complicated.</p>
<p>RP T = RP K</p>
<p>What about something like $\rpt \# T^2$? &hellip;since $K = \rpt \# \rpt,$</p>
<p>CLASSIFICATION</p>
<p><strong>Theorem (classification of surfaces)</strong>: a surface is either homeomorphic to</p>
<ul>
<li>
<p>The sphere $S^2$;</p>
</li>
<li>
<p>A connected sum of torii $T^2\#...\# T^2$;</p>
</li>
<li>
<p>Or a connected sum of projective planes $\rpt \# ... \# \rpt.$</p>
</li>
</ul>
<h2 id="delta-spaces">Delta spaces</h2>
<p>Finding triangulations for topological spaces can be a great exercise to understand simplicial complexes, but it&rsquo;s also quite tedious. This is because we strictly require that our spaces be composed of simplices, which in particular aren&rsquo;t curved. This is a quite strong restriction. But what if we just asked for it to be composed of <strong>images of simplices</strong>? This way, we could stretch and manipulate simplices, and try to see our space as the union of these distorted polygons.</p>
<p>For the circle, e.g., instead of making it with three 1-simplices, forming the boundary of a triangle, we could just take one 1-simplex and glue its ends together&ndash; thus forming a loop. This wouldn&rsquo;t be a simplicial complex, but would still be an image of one, with just one altered 1-simplex.</p>
<p>For the torus, instead of the exhausting triangulation we could describe it as the image of a complex as follows: take a quad and glue its sides exactly as in the description of the torus from a square. Similar can be done for all surfaces we studied above. These are not complexes, but are <strong>continous images</strong> of complexes.</p>
<p>IMG! S1 T2</p>
<p>This gives us the notion of a $\Delta$<strong>-space</strong>. Technically, it is a space $X$ with a set $S$ of maps $\sigma_i:\Delta^k\rightarrow X$, for different $k$. We require, similarly to the simplicial case, that if $\sigma \in S$, then for all the faces $F$ of $\Delta^k$, the restriction $\sigma \mid F$ of $\sigma$ to $F$ (which can be described as a map $\tau: \Delta^{k-1}\rightarrow X$) is also in $S$. We also ask that the restriction of $\sigma$ to the interior $\Delta^k\setminus \partial \Delta^k$ is injective (so that the images of these maps are filled), and that every point in $X$ is inside $\im \sigma$ for some $\sigma\in S$ (the image of maps in $S$ fill $X$). It is common to call such set $S$ a &ldquo;<strong>delta structure</strong>&rdquo; over $X$.</p>
<p>In the circle example we gave above, we have $S=\{\sigma_0, \sigma_1\}$, with $\sigma_0:\Delta^0\rightarrow S^1$ having image a single vertex $v_0$, and $\sigma_1:\Delta^1\rightarrow S^1$ a function such that $\sigma_1(0)=\sigma_1(1)$, giving a loop with base point $v_0$.</p>
<p>In the torus example we gave above, we have $S=\{\sigma_0,\sigma_1,\sigma_2,\sigma_3,\sigma_4,\sigma_5\}$, where $\sigma_0:\Delta^0\rightarrow T^2$ maps to the corner point $v$, $\sigma_1:\Delta^1\rightarrow T^2$ maps to the edge labeled $a$, $\sigma_2$ to $b$ and $\sigma_3$ to $c$. Then $\sigma_4:\Delta^2\rightarrow T^2$ maps to one of the triangles with edges $a,b,c$, and $\sigma_5$ to the other one.</p>
<p>Note: with delta structures, we&rsquo;re dealing with functions here, not with spaces directly. However, it will still be pretty common for us to call the maps in the structure by their images. So, in the example above for $T^2$, we&rsquo;ll usually call $\sigma_0$ just as $v$, $\sigma_1$ as $a$, $\sigma_2$ as $b$, $\sigma_3$ as $c$, $\sigma_4$ as $U$ and $\sigma_5$ as $L$, even though this is a little stretch of our terminology.</p>
<p>Delta spaces will simplify our computations a lot, so here are some ways of describing the surfaces we&rsquo;ve discussed so far as $\Delta$-spaces (note again that these are just the square representation we studied applied to a quad):</p>
<p>IMGS!!!</p>
<h1 id="3d-graphics-and-the-algebra-of-holes">3D graphics and the algebra of holes</h1>
<h2 id="meshes-and-simplices">Meshes and simplices</h2>
<p>Simplices and simplicial complexes shouldn&rsquo;t be foreign to those artists working with 3D rendering. In this area, they go by the name of <strong>meshes</strong>, which are just simplicial complexes constructed only gluing 2-simplices, plus some extra data we will discuss below.</p>
<p>Meshes have different implementations on different frameworks, but here is a quite minimalistic one we&rsquo;ll use in this post:</p>
<div class=""><div style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">Mesh</span>{
</span></span><span style="display:flex;"><span>    vec3[] vertices;
</span></span><span style="display:flex;"><span>    vec2[] uv; <span style="color:#080;font-style:italic">// UV maps, allow for textures. See below.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}</span></span></code></pre></td></tr></table>
</div>
</div>
<p>In the structure above, each three consecutive elements of the array <code>vertices</code> represent a triangle in the simplicial structure. The standard 2-simplex $\Delta^2$ embedded in $\rth$, for example, has <code>vertices = [(0, 0, 0), (1, 0, 0), (0, 1, 0)]</code>; the standard quad may have <code>vertices = [(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)]</code>. Finally, defining <code>v0 = (0, 0, 0), v1 = (1, 0, 0), v2 = (0, 1, 0), v3 = (0, 0, 1)</code>, the boundary of the standard 3-simplex  $\Delta^3$  may be given <code>vertices = [v1, v2, v3, v0, v2, v2, v0, v1, v3, v0, v1, v2]</code> (this may seem a bit daunting, but note it is just a matter of applying the formula for the boundary we found before).</p>
<p>For each vertex, we also associate a so-called UV value, which is a vector of dimension 2. Points inside the triangle also have UV values, obtained by interpolating using their barycentric coordinates. UV maps help us texturing our surface: the $(u,v)$ value of a point in the triangle indicates that it should have the color of the pixel in position $(u,v)$ inside the texture image.</p>
<p>But why are meshes used in computer graphics? In order to answer that, it&rsquo;s neccessary to understand how 3D rendering works. The general setup is pretty similar to what we studied with projective spaces above: we have a scene, and, inside it, a point representing our camera/eye position. This camera has an associated direction and also a view plane&ndash; generally the plane with $z=1$&ndash;, which is to be interpreted as representing the 2D view the camera sees. Each point in this plane is associated, in our actual computer image, with a pixel. Rendering is the task of associating correct colors to these pixels.</p>
<p>There are two main methods used to actually render a 3D scene: <strong>rasterization</strong> and <strong>raytracing</strong>. The latter is the most intuitive: in it, for each pixel in the screen you define an infinite ray beginning from the camera and passing through the point in the vision plane associated to the pixel. Starting from the camera position, you keep &ldquo;marching&rdquo; through the ray, at each interaction choosing point further away from the camera along the ray. You do so until you hit an object in the scene. You then return data from this object (like its material, its color etc.), and use that further in your rendering pipeline.</p>
<p>IMG!!!</p>
<p>In a <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a>-like pseudo-code, this may be written as follows:</p>
<div class=""><div style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// General raytracing algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(pixel in image){
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">//vec3 is a 3D vector
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    vec3 direction <span style="color:#666">=</span> rayDirection(pixel);
</span></span><span style="display:flex;"><span>    vec3 origin <span style="color:#666">=</span> cameraPosition;
</span></span><span style="display:flex;"><span>    vec3 p <span style="color:#666">=</span> origin; <span style="color:#080;font-style:italic">// marching point
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">float</span> dO <span style="color:#666">=</span> <span style="color:#666">0.0</span>; <span style="color:#080;font-style:italic">// distance from the origin (camera position)
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#0b0;font-weight:bold">float</span> dS <span style="color:#666">=</span> <span style="color:#666">1e10</span>; <span style="color:#080;font-style:italic">// distance from a surface. Initialized as a very high number
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    SurfaceData surfaceData; <span style="color:#080;font-style:italic">// other data from hit surface
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// MIN_DISTANCE is a small number indicating the marching point is close enough to a surface
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// MAX_DISTANCE is a large number indicating the marching point is off the scene
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#a2f;font-weight:bold">while</span>(dS <span style="color:#666">&gt;</span> MIN_DISTANCE <span style="color:#666">&amp;&amp;</span> dS <span style="color:#666">&lt;</span> MAX_DISTANCE){
</span></span><span style="display:flex;"><span>        p <span style="color:#666">=</span> origin <span style="color:#666">+</span> dO <span style="color:#666">*</span> direction; <span style="color:#080;font-style:italic">// push along the ray
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        dS <span style="color:#666">=</span> distanceFromSurface(p);
</span></span><span style="display:flex;"><span>        surfaceData <span style="color:#666">=</span> getData(p);
</span></span><span style="display:flex;"><span>        dO <span style="color:#666">+=</span> dS;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pixel.color <span style="color:#666">=</span> getColor(dS, surfaceData); <span style="color:#080;font-style:italic">// use distance and surface data to get a color
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}</span></span></code></pre></td></tr></table>
</div>
</div>
<p>The crucial mathematical step in the algorithm is how to get the distance from $p$ to surfaces inside our scene. How might we find that value? The most straightaway way is to use the surfaces&rsquo; SDFs&ndash; their &ldquo;<strong>signed distance functions</strong>&rdquo;. This is a function that directly&ndash; or, using the more common mathematical term, analitically&ndash; tells you the distance between a point and an embedded (orientable) space, giving positive sign if it is &ldquo;outside&rdquo; the object, and negative if it is &ldquo;inside&rdquo; it.</p>
<p>Below is an example of a SDF for a sphere of radius $r$ and center $c$ in $\rth$:</p>
<div class=""><div style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">float</span> <span style="color:#00a000">sphereSdf</span>(vec3 p, vec3 c, <span style="color:#0b0;font-weight:bold">float</span> r){
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// length is used to get the Euclidian distance between p and c: length(v) = sqrt(v[0]^2 + v[1]^2 + v[2]^2)
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#a2f;font-weight:bold">return</span> distance <span style="color:#666">=</span> <span style="color:#00a000">length</span>(p <span style="color:#666">-</span> c) <span style="color:#666">-</span> r;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></td></tr></table>
</div>
</div>
<p>When used to render a 3D scene, this will give us a smooth sphere. Sadly, most shapes you will see on, say, video games, do not have such an easy SDF. This may change with the progress of <a href="https://research.nvidia.com/labs/toronto-ai/nglod">neural SDFs</a>, which use neural networks to learn these functions, but, for the most part of the history of computer graphics, using a SDF for an entire arbitrary shape wasn&rsquo;t viable.</p>
<p>The solution was to try to approximate surfaces using simplers shapes&ndash; namely, triangles, or 2-simplices, for which we can use a single known SDF (<a href="https://www.shadertoy.com/view/4sXXRN">see here</a> for an implementation). And so were meshes born, as complexes made by these triangles. That is, meshes are just triangulations of surfaces we want to approximate.
The more 2-simplices a mesh has, the more detail our model will be able to have.</p>
<p>The reader might have noted that there is a slight mathematical problem here: SDFs only really work with orientable surfaces! This is a problem if you try to render a Möbius strip directly using a single SDF, but not really if you approximate it using triangles. Still, as we will soon see, orientation does provide some problems for 3D rendering.</p>
<p>Raytracing is great for phisically correct rendering, since it closely resembles how light actually works. Doing something like reflection, for example, is pretty straightforward: when your surface is reflective and it has been hit by a marching point, just make it follow a new ray normal to the hit point, &ldquo;bouncing&rdquo; the marching ray. Then when it hits another surface, combine the colors of the found objects. This technique of bouncing rays is fundamental to raytracing techniques like <a href="https://en.wikipedia.org/wiki/Path_tracing">path tracing</a>.</p>
<p>There is, however, the problem that it can take too much time inside the <code>while</code> loop trying to hit a surface, making it computationally expensive. Rasterization is then a more efficient alternative. In it, we project our mesh triangles into the vision plane&ndash; something that can be quickly done by the GPU using linear algebra and projectivization. For each pixel we then check if it is contained inside one of these projected triangles, and use that to define its color.</p>
<p>We also have to check in the case a pixel is inside many of these triangles&ndash; for example, if we have two triangles in our scene, one behind the other in relation to the camera. To solve that, we compare each point projecting to that pixel, and render only the color associated to the point closest to the camera- i.e., the one with least &ldquo;depth&rdquo;. These depth values for each pixel are stored in an array called the <strong>depth buffer</strong>.</p>
<p>IMG!!!</p>
<div class=""><div style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// General rasterization algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(pixel in image){
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> pixel[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> y <span style="color:#666">=</span> pixel[<span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(triangle in scene){
</span></span><span style="display:flex;"><span>        vec2 v0 <span style="color:#666">=</span> project(triangle[<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>        vec2 v1 <span style="color:#666">=</span> project(triangle[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>        vec2 v2 <span style="color:#666">=</span> project(triangle[<span style="color:#666">2</span>]);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">float</span> depth;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(pixelInTriangle(v0, v1, v2, <span style="color:#666">&amp;</span>depth)){ 
</span></span><span style="display:flex;"><span>            <span style="color:#080;font-style:italic">// pixelInTriangle changes the depth value to be the depth of the projected triangle
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            <span style="color:#a2f;font-weight:bold">if</span>(depth <span style="color:#666">&lt;</span> depthBuffer[x, y]){
</span></span><span style="display:flex;"><span>                image[x, y] <span style="color:#666">=</span> triangle.color;
</span></span><span style="display:flex;"><span>                depthBuffer[x, y] <span style="color:#666">=</span> depth;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></td></tr></table>
</div>
</div>
<p>Meshes become more interesting when you introduce <strong>lighting and shading</strong> to your rendering pipeline. Imagine you have a lamp on a point $O$ on your 3D scene, and want to use it to illuminate objects. One of the basic ways to do so is as follows: for each point $P$ in a surface, trace a line from $P$ to $O$. In vector terms, get $O-P$. Then you find the normal $N_P$ of the surface at $P$. If they are colinear and point in the same direction, this means $P$ is standing right in front of $O$, so that, if it isn&rsquo;t obstructed by any other object, it should receive maximum lighting. That is: the closest $P$ and $N_P$ are to being pointing in the same direction, the more iluminated $P$ should be. That&rsquo;s exactly what the dot product measures, so the lighting $L(P)$ in $P$ is proportional to $(O-P)\cdot N_P$, and so it should also be in relation to the intensity $I$ of the lamp. It also should be inversely proportional to the distance $d(O,P)$, and be strictly positive. This means we might model $L(P)$ with the following formula:</p>
$$L(P) = \max (I\, \frac {(O-P) \cdot N_P} {d(O, P)}, 0)$$<p>Note that, as we&rsquo;re using normals, this method doesn&rsquo;t really work with non-orientable surfaces&ndash; which, again, isn&rsquo;t really the end of the world. The real problem is: how to get $N_P$ for all $P$? Using meshes, this is actually pretty simple: if $\angled{v_0, v_1, v_2}$ is a 2-simplex, then its normal should be a vector ortogonal to the plane containing $v_1 - v_0$ and $v_2 - v_0$, which can be computed using the cross product. The question is, however, in each direction should this normal point to&ndash; i.e., if we use $(v_1 - v_0)\times (v_2 - v_0)$ or $(v_2 - v_0)\times (v_1 - v_0)=-(v_1 - v_0)\times (v_2 - v_0)$. The <strong>convention</strong> is to do $(v_1 - v_0)\times (v_2 - v_0)$, and we call this the &ldquo;<strong>positive orientation</strong>&rdquo; of the 2-simplex, the other possibility being the negative orientation.</p>
<p>We can quickly integrate orientation in our mesh structure. Indeed, for each three consecutive vertices <code>v0, v1, v2</code> representing a triangle in the array <code>vertices</code>, we&rsquo;ll use the positive orientation in $\angled{v_0, v_1, v_2}$. Presenting everything in the correct order then becomes very important&ndash; if we get a single triangle wrong, our mesh will be shaded in an absurd way, with some triangles being suddenly bright and other suddenly dark because of the wrong orientations.</p>
<p>We interpret the orientation of a triangle as also being associated with one of its edges: in the positive one, we see edges going in the directions <code>v0 -&gt; v1</code>, <code>v1 -&gt; v2</code> and then <code>v2 -&gt; v0</code>&ndash; i.e., going ing the counter-clockwise way&ndash;, and then negative one going the other way around. This allows us to use the <strong>right-hand rule</strong>: take your right hand and curl your fingers in the direction the triangle&rsquo;s edges take, except the thumb; then extend your thumb, and that is the the direction of the normal vector giving the orientation.</p>
<p>IMG right hand e mesh na orientac positiva</p>
<p>That is, an orientation of a 2-simplex also orients its faces. The opposite is also true: if we have the direction the edges follow, we have also have an orientation. Actually, even more: if we have a <strong>single</strong> edge direction, we can deduce the others&rsquo; as well, and so we also have an orientation.</p>
<h2 id="orientations-and-boundaries">Orientations and boundaries</h2>
<p>With the discussions above, it really seems like orientation is a very relevant topological property with important applications. Meshes also showed us how to integrate this notion with complexes&ndash; which, per se, are just sets of points, without any orientation information. So perhaps we&rsquo;d like to do this same move in the mathematical level, getting &ldquo;<strong>oriented simplices and complexes</strong>&rdquo; which do come with some orientation, and non-oriented simplices will sometimes be called <strong>geometrical</strong>. This will also require a change in terminology: instead of writing $\angled{v_0,...,v_n}$, we&rsquo;ll write $[v_0,...,v_n]$ for this new kind of spaces, and order will matter in the presentation. Similarly to the 2-simplex case, giving an orientation to an n-simplex will be equivalent to giving one for one of its faces.</p>
<p>Let&rsquo;s begin orienting 1-simplices. This is simple: if 1-simplices are line segments, their oriented versions will be seen as directed paths. We will say $\os$ is an oriented simplex with base $\angled{v_0,v_1}$, and going from $v_0$ to $v_1$&ndash; $[v_1,v_0]$ then being the oriented simplex going in the opposite direction. In the same way meshes&rsquo; orientations were associated to the orientation of their edges, may say that $\os$ gives $[v_1]$ a &ldquo;positive&rdquo; orientation and $[v_0]$ a &ldquo;negative&rdquo; one.</p>
<p>IMG!!! ORIENTAC 1</p>
<p>Reiterating, this all means that, with oriented simplices, the order we write our base vectors in $[v_0,...,v_k]$ will from now on matter.</p>
<p>Formalizing for the 2-dimensional case, we determine that $\ts$ has oriented edges $[v_0, v_1]$, $[v_1,v_2]$ and $[v_2,v_0]$. The other possible oriented 2-simplex would be the one with inverted edges $[v_1,v_0]$, $[v_0,v_2]$ and $[v_2,v_1]$, which can then be written as $[v_1,v_0,v_2]$. Indeed, whenever you swap two neighboring vectors in the presentation, you get the 2-simplex going in the opposite direction. This means that if you do an odd amount of swaps (in what we will call an <strong>odd permutation</strong>), you get the opposite simplex; if you do an even amount (in an <strong>even permutation</strong>), you get the same one. For example, $[v_1,v_2,v_0]$ is an even permutation of $[v_0,v_1,v_2]$ (the $v_0$ was swapped twice, first with $v_1$ and then with $v_2$), so that $[v_1,v_2,v_0]=\ts$, which can be seen by their edges following the same directions. Similarly, $[v_1,v_0,v_2]=[v_0,v_2,v_1]$.</p>
<p>You can see the rule above also applies for 1-simplices, and indeed will be the case for <strong>any</strong> n-simplex.</p>
<p>IMG !!! (MOSTRANDO COMO SE DESENHA ORIENTAC P/ TRIANGULO, BARICENTRICO TBM)</p>
<p>Suggestively, we may write $-[v_0,...,v_k]$ for the simplex with the opposite orientation of $[v_0,...,v_k]$. In particular, we just saw that $[v_0,v_1]=-[v_1,v_0]$ and</p>
$$\ts=[v_1,v_2,v_0]=-[v_1,v_0,v_2]=-[v_0,v_2,v_1],$$<p>for example.</p>
<p>We can also see from the manner we defined orientations so far that defining an orientation for 1 and 2-simplices is actually the same as giving an orientation for all its faces. In both cases, for a simplex $[v_0,...,v_k]$, we used the convention that $[v_1,...,v_k]$ (excluding the first vector from the presentation) was one of its oriented edges&ndash; $[v_1]$ in the case of $\os$, $[v_1,v_2]$ in the case of $\ts$.</p>
<p>Generalization is now straightforward. From now on, $[v_0,...,v_k]$ will denote an <strong>oriented k-simplex</strong>. We will use the convention that it has $[\widehat{v_0},...,v_k]$ as one of its faces, which we&rsquo;ll soon see as also being enough to define the orientation of every other face. What we noted for 1 and 2-simplices with regard to permutations is still valid: odd permutations of vertices in the presentation give the opposite simplex, even ones give you the same simplex. From now on, we&rsquo;ll also call &ldquo;oriented simplices&rdquo; just &ldquo;simplices&rdquo; if it&rsquo;s clear from the context.</p>
<p>What about complexes? We&rsquo;ll say a simplicial complex is oriented if we give each of its simplices an orientation. There are many possible such orientations. Applying to 3D rendering, each of these orientations represents a way of shading our mesh. In many of these, neighbouring triangles have different orientations, resulting in suddenly light or dark regions, which isn&rsquo;t an effect we really desire. For orientable surfaces, we might want to find a single, &ldquo;canonical&rdquo;, orientation such that all triangles have coherent normals, so that the whole surface will have a smoother and cohesive lighting&ndash; indeed, that&rsquo;s precisely the definition of an orientable surface.</p>
<p>SHADER!!! cilindro mal orientado</p>
<p>To obtain this orientation, consider the example of the standard quad with vertices labeled $v_0=(0,0),$ $v_1=(1,0),$ $v_2=(0,1),$ $v_3=(1,1)$. Say we orient the first triangle as $\ts$, so that, using the right-hand rule, its normal points towards us. What orientation should we give to the other triangle so that its normal may have the same direction? Again using the right-hand rule, it should be $[v_1, v_3, v_2]$. Note that, at their common edge, they have different orientations: one has $[v_1, v_2]$ as an edge, the other $[v_2, v_1]$.</p>
<p>This is valid in general: every time you glue two n-simplices together and you want them to have coherent normals (either both pointing outwards or inwards), their common $n-1$ face should come from faces of the opposite direction in each original simplex. Orientable surfaces are exactly those that can be approximated by oriented simplices satisfying this property for all simplices with common faces.</p>
<p>For example, this <strong>can</strong> be done on the triangulation we provided for the torus, as shown belown.</p>
<p>IMG!!! (ESQUEMA, SHADER)</p>
<p>As a result, we can correctly shade this triangulation&ndash; and, since orientability is a topological property, this applies for any other mesh representing a torus:</p>
<p>SHADER!!!</p>
<p>For example, that&rsquo;s something you <strong>can&rsquo;t</strong> do in the triangulation we presented of the Möbius strip. Consider, say, the orientation provided in the image below, where we&rsquo;re trying to which can be noted on the triangles at the horizontal extremes: they meet booth in the same oriented face $[p_0, p_5]$! Any other orientation will eventually have the same problem.</p>
<p>IMG!!! (ESQUEMA, SHADER)</p>
<p>As a result, we can&rsquo;t shade this Möbius strip triangulation correclty&ndash; and, since orientability is a topological property, this applies for any other mesh representing the strip:</p>
<p>SHADER!!!</p>
<p>This rule for getting coherent normals is valid for the boundary of n-simplices as well, since these are complexes. For example, suppose we wish to have coherent orientations on $\partial \angled{v_0, v_1, v_2}$. This complex a collage of 1-simplices forming a triangle. The rule above says that if two edges are glued, then one&rsquo;s end must be the other&rsquo;s starting point (remember, a point has positive orientation in a 1-simplex if it is its end point). Thus, if we have the orientation of a single edge and want to orient the boundary coherently, all we have to do is follow this rule and we will get the other edge directions as well.</p>
<p>Let&rsquo;s see how this works in the example of a 3-simplex $\ths$. By our convention, it has an oriented face $[v_1,v_2,v_3]$. This 2-simplex shares the oriented edge $[v_2,v_3]$ with $\angled{v_0,v_2,v_3}$, so the oriented version of the latter must contain the edge $[v_3,v_2]$ going in the opposite direction, and so it must be $-[v_0,v_2,v_3]$. Doing similarly for all other faces of the pyramid, we get that its oriented faces are $[v_1,v_2,v_3]$, $-[v_0,v_2,v_3]$, $[v_0,v_1,v_3]$ and $-[v_0,v_1,v_2]$.</p>
<p>IMG!!!!</p>
<p>In particular, this means that if we have the orientation of a single face on an orientable complex, we can deduce the orientation of all other faces, by just applying this rule of &ldquo;opposite orientation on intersection&rdquo;. Since simplices themselves are orientable, this can be done for them as well: a single face orientation forces the orientation of the whole simplex&ndash; either positive or negative.</p>
<p>These considerations actually allows us to get a formula for the oriented faces of a simplex $[v_0,...,v_k]$. We know that its geometrical faces are all the possible $\langle v_0,...,\widehat{v_i},...,v_k\rangle$, so we just need to find their <em>oriented</em> versions. We have one already: $[\widehat{v_0},...,v_k]$, by our convention. As for the orientation of $\angled{v_0,\widehat{v_1},...,v_k}$, we see that it shares the face $\angled{v_2,...,v_k}$ with $[\widehat{v_0},...,v_k]$, and so these must have opposite orientations&ndash; i.e., we have the negatively oriented face $-[v_0,\widehat{v_1},...,v_k]$. Going by a similar procedure, we see that $\langle v_0,...,\widehat{v_{i+1}},...,v_k\rangle$ always has the opposite orientation of $\langle v_0,...,\widehat{v_i},...,v_k\rangle$, so that orientations alternate between positive and negative, beginning from $[\widehat{v_0},...,v_k]$ with a positive one. Thus, using our suggestive sign notation, we get that the <strong>oriented</strong> faces of $[v_0,...,v_k]$ are</p>
$$(-1)^i[v_0,...,\widehat{v_i},...,v_k],$$<p>for $0\leq i\leq k$.</p>
<h2 id="doing-algebra-with-faces">Doing algebra with faces</h2>
<p>Now that we know how to describe faces, we can define the boundary of an oriented n-simplex $a$, denoted $\partial_n (a)$ or simply $\partial (a)$ when the dimension is clear (we&rsquo;ll also ommit the parenthesis when possible). For an isolate geometrical simplex $\angled{v_0,...,v_k}$, remember we have</p>
$$\partial \angled{v_0,...,v_k} = \bigcup_{i=0}^n \angled{v_0,...,\widehat{v_i},...,v_k},$$<p>and, for an oriented simplex, we just found out that</p>
$$\partial [v_0,...,v_k] = \bigcup_{i=0}^n (-1)^i[v_0,...,\widehat{v_i},...,v_k]$$<p>But what about the union of simplices $a,b$ inside a simplicial complex? For geometrical simplices, we should have this as the union of their boundaries, disconsidering common faces, since these are part of the &ldquo;interior&rdquo; of the union:</p>
$$\partial (a\cup b)=\bigcup_{e\in (\partial a \cup \partial b) - (\partial a \cap \partial b)}e$$<p>What about for oriented simplices? Take as an example two 2-simplices $a=\ts$ and $b=[v_1,v_3,v_2]$ forming a quad along the edge $\angled{v_1,v_2}$. In that case, $\partial a = [v_1,v_2]\cup-[v_0,v_2]\cup[v_0,v_1]$ and $\partial b = [v_3,v_2]\cup-[v_1,v_2]\cup[v_1,v_3]$. Similarly to the geometric case, their common face should be disconsidered for the boundary of the union. But note something: the common canceled face has opposite orientation in these simplices, so it is as if it was being &ldquo;canceled&rdquo;&ndash; exactly like in a sum. This means there might be some algebra going behind the curtains!</p>
<p>Indeed, let us think of union of oriented simplices as a kind of a sum, and opposite orientations giving us negative sign. We write $a-a=0$, indicating that faces of opposite orientation should be cancelled in a sum. We can understand $0$ as the null set, or some sort of formal &ldquo;null n-simplex&rdquo;, satisfying $a+0=0+a=a$ for any simplex $a$. In that case, we could write something like</p>
$$\partial_n([v_0,...,v_n]) = \sum_{i=0}^n (-1)^i [v_0, ..., \widehat{v_i}, ..., v_n]$$<p>And then postulate $\partial(a + b)=\partial a + \partial b$, so that, in the example above, we may have</p>
$$\begin{align}
    \partial (a+b)=\partial a + \partial b &= ([v_1,v_2]-[v_0,v_2]+[v_0,v_1])+([v_3,v_2]-[v_1,v_2]+[v_1,v_3])
                                         \\&= -[v_0, v_2]+[v_0,v_1]+[v_3,v_2]+[v_1,v_3],
\end{align}$$<p>which indeed represents the boundary of $a\cup b$ with the correct orientations. Pay attention, however, that this <strong>isn&rsquo;t a union</strong>, but a merely <strong>formal sum</strong>. We may <em>think of it as a union</em> for intuition, but it&rsquo;s not one! We&rsquo;re introducing a layer of (useful) abstraction here.</p>
<p>Note how this boundary follows some sort of &ldquo;linearity&rdquo;, as do linear transformations. This leads us to think in algebraic terms, revealing potential extra structure involved with oriented simplices. Structures and connections: these are a mathematician&rsquo;s dream!</p>
<p>Quite importantly, we think of the sums above as independing of order: i.e., $a+b=b+a$ for any simplices $a,b$. We also assumed it&rsquo;s associative: $(a+b)+c=a+(b+c)$ for all $a,b,c$, so that parenthesis don&rsquo;t matter doing sums.</p>
<p>Summing works great with different simplices, but what about something like $a+a$? We know that $a\cup a = a$, so perhaps we should write $a+a=a$? But since we have inverses, this would mean that we could subtract both sides by $-a$, getting $a=0$&ndash; which doesn&rsquo;t seem good at all. The second most natural option would be to write $a+a = 2a$, which wouldn&rsquo;t bring any algebraic problems. We could interpret this as &ldquo;following&rdquo;, or &ldquo;transversing&rdquo; $a$ twice. That is, we can understand these algebraic elements as &ldquo;transversions&rdquo; of simplices, or a generic action over our simplex, so that this formal addition we&rsquo;re describing may be better intuitively understood as a &ldquo;composition&rdquo; of these actions. In the case of a 1-simplex, $2a$ would be as following the the directed path described by it twice; for a 2-simplex, it is like doing a twist twice along the triangle, based on the given orientation. This is more intuition than a formal relation, but it shows how geometrical simplices have a <strong>static, set-like</strong> logic, while oriented ones can indeed have a <strong>dynamic, algebraic</strong> one.</p>
<p>According to the linearity property described above, we also set $\partial(n\cdot a)=n\partial(a)$, $n$ and integer.</p>
<p>How to formalize this? Well, we will do that properly in the next section when we talk groups, but let us summarize the major points. For a simplicial complex $X$, let $a_0,...,a_k$ be all its n-simplices. Then we saw that it makes senses to consider formal finite sums $n_i \cdot a_i+...+n_j\cdot a_j$, $n_i$ being any integer&ndash; possibly even negative or equal to $0$. We also write $a_i-a_i=0$, $0$ being a null, formal element (note that we only sum simplices of the same dimension). We also set the rules $a+0=0+a=a$ and $0a=0$. This sum and multiplication work like vector sum and scalar multiplication, basically satisfying all the properties we used to define vector spaces above (commutativity, distributivity, etc.). We&rsquo;ll call these sums <strong>n-chains</strong>, and say they form the set of n-chains $C_n(X)$. We also described a function $\partial _n : C_n(X)\rightarrow C_{n-1}(X),$ given by the formula above, satisfying some sort of linearity condition: $\partial_n(a+b)=\partial_n (a) + \partial_n (b)$ (note that the same $+$ symbol in each side represent operations on the different sets $C_n(X)$ and $C_{n-1}(X),$ respectively) and $\partial(n\cdot a)=n\partial(a)$.</p>
<p>The sets $C_n(X)$ above depend on the simplicial complex we&rsquo;re using to model $X$, but, thankfully, this won&rsquo;t actually matter for the computations involving holes we&rsquo;ll do later. They also don&rsquo;t depend on any choice of orientation, since all possible oriented simplices of our complex are contained as chains in $C_n(X)$.</p>
<p>Notice that the $C_n(X)$ really look similar to vector spaces (and $\partial_n$ to linear transformations), but, since we only allowed here for integet scalar multiplication, they are not vector spaces! They&rsquo;re actually cases of another algebraic structure, namely <strong>modules</strong> (which we&rsquo;ll study soon) which are generalizations of vector spaces.</p>
<p>Finally, note that $C_n(X)$ always contains the null element $0$, even when the complex $X$ contains no n-simplices. In particular, if that&rsquo;s the case, then $\partial_n(0)=0$, and we may write $\partial_n=0$.</p>
<h2 id="the-case-of-delta-spaces">The case of delta spaces</h2>
<p>These considerations can all be generalized to the delta space case. See, the maps $\sigma:\Delta^k\rightarrow X$ we considered before don&rsquo;t have any notion of orientation&ndash; and, in particular, of normals on our space. We can orient these maps by seeing them as functions from oriented simplices, not geometric ones, so that the orientation of their domains will matter. We may write something like $\sigma : [v_0,...,v_k]\rightarrow X$ instead of $\sigma:\angled{v_0,...,v_k}\rightarrow X$ to indicate $\sigma$ inherits its orientation from $[v_0,...,v_k]$&ndash; and not, say, from $-[v_0,...,v_k]$, in which case we could write we have $-\sigma$. That is, for each $\sigma$ in the delta structure, we have oriented maps $\sigma$ and $-\sigma$, according to the orientation we give to the domain simplex.</p>
<p>Here are the delta structures we presented before, but now oriented so that at least the oriented surfaces will have coherent normals:</p>
<p>IMGS!!! (oriented deltas)</p>
<p>With oriented delta structures, we can generalize the rest of our previous definitions. We&rsquo;ll let $C^\Delta _n(X)$ be the set of formal finite sums $n_i\sigma_i+...+n_k\sigma_k$, $n_j\in\mathbb{Z}$ and the $\sigma_j$ being part of the delta structure we&rsquo;re using on $X$. These sums will also be called n-chains. We can then define the boundary map $\partial_n:C^\Delta _n(X)\rightarrow C^\Delta _{n-1}(X)$ of a map $\sigma:\Delta^n\rightarrow X$ as</p>
$$\partial_n(\sigma) = \sum_i (-1)^i \sigma \mid   [v_0, ..., \widehat{v_i},..., v_n],$$<p>and we extend to sums and products linearly: $\partial_n(a+b)=\partial_n(a)+\partial_n(b)$, $\partial(n\cdot a)=n\partial(a)$.</p>
<p>Note that, since $\sigma$ has signature $\Delta^n\rightarrow X$, the $v_i$ here refer to the vertices of the standard simplex, with $v_0$ the origin and $v_i\in\mathbb{R}^{n}$ having a $1$ in its $i$-th coordinates and $0$ elsewhere. Similarly to the simplicial case, the definition of $C^\Delta(X)$ depends on the delta structure, but not on specific orientations.</p>
<p>For example, seeing the circle as a delta space as we described previously with $\sigma$ is the only 1-chain in the structure, we have that $\partial_1(\sigma)=\sigma\mid  [v_1]-\sigma\mid  [v_0]=0$ since $\sigma\mid  [v_1]=\sigma\mid  [v_0]$.</p>
<p>For the torus as a delta space, we have that, for example, $\partial U = U\mid [v_1,v_2]-U\mid [v_0,v_2]+U\mid [v_0,v_1]$. Using the vertex labels above, $U\mid [v_1, v_2]=-b,$ $-U\mid[v_0,v_2]=-a$ and $U\mid[v_0,v_1]=c.$ An easier way to see this is just to follow the orientation of the boundary induced by $U$ and note it transverses $c,$ then $-a$ and then $-b,$ so that $\partial U = -b-a+c.$ Similarly, $\partial L = a-c+b.$ Thus,</p>
$$\begin{align}
\partial_2(U+L)=\partial_2(U)+\partial_2(L)&=(U\mid  [v_1,v_2]-U\mid  [v_0,v_2]+U\mid  [v_0,v_1]) 
\\&\,\,\,\,\,\,\, + (L\mid [v_1,v_2]-L\mid [v_0,v_2]+L\mid [v_0,v_1])
\\&=(-b-a+c)+(a-c+b)=0
\end{align}$$<p>As intended, the chain corresponding to the whole torus surface has null boundary!</p>
<p>The torus also has 1D cycles: these are $a, b, c$ and all their possible linear combinations, since the boundary is itself linear. This is easy to see, since all of these begin and end at the same vertex $v.$</p>
<h2 id="cycles-and-holes">Cycles and holes</h2>
<p>Let&rsquo;s dive a little deeper into how we can use the geometry of simplices, chains and their boundaries to study general topological spaces. What we&rsquo;ll say here will apply both to $C_n(X)$ and $C^\Delta_n(X).$</p>
<p>First, boundaries allow us to properly define what &ldquo;<strong>cycles</strong>&rdquo; mean. As mentioned in the introduction, these correspond to loops on our space, but also to hollow surfaces, and the corresponding higher-dimensional cycles. What these have in common is that they are &ldquo;boundaryless&rdquo;, in some sense &ldquo;self-enclosing&rdquo;. We can thus describe these as the chains $c$ with null boundary, $ \partial_n(c)=0.$ We can reuse the terminology of linear algebra and then define the set of n-cycles in $X$ as $Z_n(X)=\ker \partial_n.$</p>
<p>Still, there are many cycles that don&rsquo;t give rise to holes, and, as discussed, this is exactly because they&rsquo;re boundaries of some chain of the above dimension. Formally, these are the chains in the image of the boundary map, and form the set n-boundaries, $B_n = \im \partial_{n+1}.$</p>
<p>In the example of the delta structure on circle $S^1$, we have only one $\sigma:\Delta^1\rightarrow S^1$ with $\partial \sigma = 0$, as seen above, which then represents a cycle. Since we have no 2-chains, $\partial_2 = 0$, so $\sigma$ is not a boundary of anyone, and thus it represents an actual hole. For $D^2$ as the simplex $\Delta^2$, we have a similar situation with the one 1-chain $c=[v_0,v_1]+[v_1,v_2]+[v_2,v_0]$ which is a cycle, but it&rsquo;s also the boundary of the 2-chain $U = [v_0, v_1, v_2]$ representing the surface of the triangle&ndash; i.e., $c$ is &ldquo;filled out&rdquo; by $U$, and thus can&rsquo;t be interpreted as giving rise to a hole.</p>
<p>That is, $S^1$ has a hole represented by a non-boundary cycle, but $D^2$ hasn&rsquo;t because it has been filled by a 2-chain (a 2D surface). Similarly happens with the chain $U+L$ representing the entire torus surface above, which is a non-bounded cycle as well.</p>
<p>The formula we gave above for the boundary allows us to easily prove one of the most important facts in all of algebraic topology (and, indeed, of many other areas of math as well): $ \partial_{n-1}(\partial_n (\sigma))= 0$&ndash; more succintly, $ \partial_{n-1}\circ \partial_n=0$, or even $ \partial ^2=0$&ndash; for any chain $\sigma$. Visually, this means that <strong>boundaries are boundaryless, or, equivalently, all boundaries are cycles</strong>! In particular, this implies $ \operatorname{im} \partial_{n+1} \subseteq \ker \partial_n$.</p>
<p>To prove $\partial^2=0$ is actually just a matter of computation (we do it for delta spaces, but for complexes it&rsquo;s really the same thing):</p>
$$\begin{align}
\partial_{n-1}(\partial_n \sigma) &= \partial_{n-1}(\sum_i (-1)^i \sigma \mid   [v_0, ..., \widehat{v_i},..., v_n])
\\&= \sum_{j< i} (-1)^i(-1)^j\sigma\mid[v_0,...,\widehat{v_j},...,\widehat{v_i},...,v_n]
\\&\,\,\,\,\,\,\, + \sum_{j>i} (-1)^i(-1)^{j-1}\sigma\mid[v_0,...,\widehat{v_i},...,\widehat{v_j},...,v_n],
\end{align}$$<p>where we have $j-1$ in the last sum because, since $j>i$, the vertex $v_i$ was already skipped in the presentation. For any pair $i,j$ such that $i>j$, we get a term $(-1)^i(-1)^j\sigma\mid[v_0,...,\widehat{v_j},...,\widehat{v_i},...,v_n]$ in the first sum. But we also get the term $(-1)^j(-1)^{i-1}\sigma\mid[v_0,...,\widehat{v_j},...,\widehat{v_i},...,v_n]$ in the other one. These cancel each other; as the sums are only made of these terms, we get that $\partial_{n-1}(\partial_n \sigma)=0$ for any $\sigma$.</p>
<p>As discussed in the introduction, however, <strong>holes are classes of cycles</strong>. Let&rsquo;s cosnider the cylinder triangulation we used before. In it, the two horizontal chains $c_1=[v_1,v_0]+[v_4,v_1]+[v_6,v_4]$ and $c_2=[v_3,v_2]+[v_5,v_3]+[v_7,v_5]$ are both cycles, and they represent the loops at the ends of the cylinder. They should be seen as representing the same hole, and we discussed this should be because their geometric union is the boundary of the whole cylinder. Let&rsquo;s try to use our new concepts to formalize this, specially since we introduzed orientations.</p>
<p>IMG!!! (cilindro)</p>
<p>If we take the chain</p>
$$U=[v_0,v_1,v_2]+[v_1, v_3, v_2]+[v_1,v_4,v_3]+[v_4,v_5,v_3]+[v_4,v_6,v_5]+[v_6,v_7,v_5]$$<p>representing the whole cylinder surface (with all triangles counter-clockwise oriented, as in the image above), then we get $\partial U=c_1-c_2$, since, as discussed before, all the edges between triangles get eliminated. This sort of represents the union of $c_1$ and $c_2$, but with the last loop going in the opposite direction as $c_1$. Or, rather, it transverses $c_1$ and $c_2$, but with the last one going in the other direction. This characterizes $c_1$ and $c_2$ as representing the same hole in the cylinder.</p>
<p>In the purely geometrical case, we would have $\partial U = c_1 \cup c_2$, but in the oriented case we must pay attention to the sign of the chains.</p>
<p>In general, we will say that n-chains $c_1$ and $c_2$ in our space $X$ are members of the same &ldquo;hole class&rdquo; whenever there exists a $(n+1)$-chain $a$ such that $\partial a = c_1 - c_2$, or, equivalently, $c_1 = c_2 + \partial a$. We then say that these chains &ldquo;<strong>differ by a boundary</strong>&rdquo;.</p>
<p>Mathematically, this fits perfectly with the notion of a <strong>quotient</strong> in group theory. Thus, we can&rsquo;t avoid it anymore: it&rsquo;s time to introduce group theory formally into our study.</p>
<h1 id="homology-theory">Homology theory</h1>
<h2 id="homology-groups">Homology groups</h2>
<p>With all this group theory machinery, we can finally define our <strong>homology groups</strong> where holes live.</p>
<p>Given a simplicial complex $X$, we let $C_n(X)=\mathbb{Z}a_1\times ... \times \mathbb{Z}a_m$ be the $\mathbb{Z}$-module freely generated by all the n-simplices $a_1,...,a_m$ in $X$ (if there are none, $C_n(X)=0$). The boundary homomorphisms $\partial_n : C_n(X)\rightarrow C_{n-1}(X)$ are defined by the formula we got earlier: $\partial_n(\sigma) = \sum_i (-1)^i [v_0, ..., \widehat{v_i},..., v_n].$ Define $\partial_0:C_0(X)\rightarrow 0.$ to be the trivial homomorphism to the trivial group $0,$ which we also write as simply $0.$ We thus get the so-called <strong>chain complex</strong> of $X$:</p>
$$...\xrightarrow{\partial_3}C_2(X)\xrightarrow{\partial_2}C_1(X)\xrightarrow{\partial_1}C_0(X)\xrightarrow{0}0$$<p>We define the n-cycle subgroup to be $Z_n(X)=\ker \partial_n$ and the n-boundary subgroup to be $B_n(X)=\im \partial_{n+1}$. Since $\partial_n\circ \partial_{n+1}=0$, $B_n(X)\leq Z_n(X)$. Finally, the dimension n homology group of $X$ is the quotient</p>
$$H_n(X) = \frac{\ker \partial_n}{\im \partial_{n+1}}$$<p>By all our previous considerations, elements of $H_n(X)$ represent n-dimensional holes in $X$!</p>
<p>We can do the same construction with delta spaces $X$ and $C^\Delta_n(X)$, getting the homology groups $H_n^\Delta(X).$ It is a theorem we&rsquo;ll not prove here that we always have</p>
$$H_n(X)\cong H^\Delta_n(X),$$<p>i.e., it doesn&rsquo;t matter whether we use complexes or delta spaces to represent our spaces, homology groups will always be the same. We&rsquo;ll use the most convenient version depending on the specific computation.</p>
<p>Indeed, the groups $H_n(X)$ are invariant in respect to homeomorphisms: if $X$ and $Y$ are homeomorphic, then $H_n(X)=H_n(Y)$ for all $n.$ The same is true if $X$ and $Y$ are just homotopically equivalent. That is, homology is a topological invariant. We won&rsquo;t prove that here, but we&rsquo;ll lay out the neccessary tools later on.</p>
<p>It&rsquo;s now time to properly compute the homology of the spaces we&rsquo;ve been studying! We&rsquo;ll use heavy use of presentations for that: since $H_n(X)$ is abelian (since $C_n(X)$ is so), always assume we have the commutative relation $a_i+a_j=a_j+a_i$ between generators. We&rsquo;ll ommit it for brevity&ndash; so that, for example, we&rsquo;ll write $\zo^2\cong\angled{a,b}$ even thought the complete presentation is $\zo^2=\angled{a,b\mid ab=ba}.$</p>
<h2 id="holes-of-dimension-0">Holes of dimension 0</h2>
<p>Note that we also defined a trivial boundary $\partial_1$ for vertices: for $v\in C_0(X),$ $\partial_1v=0$, as <strong>all points are boundaryless</strong>. I.e., $\ker \partial_0=C_0(X).$ When are two vertices $v_0, v_1$ equivalent in the quotient? Well, whenever there&rsquo;s a 1-chain $c$ such that $\partial_1 c=v_0-v_1.$ Suppose that, for each pair of vertices $X$, there is a sequence $c_1,...,c_k$ of 1-simplices forming a path from $v_1$ to $v_0$; then $c_1+...+c_k=v_0-v_1,$ as common vertices between the lines get canceled. When this is possible, we say $X$ is <strong>path-connected</strong>. All the complexes we&rsquo;ve seen so far are path-connected, since they&rsquo;re composed of a single &ldquo;<strong>connected component</strong>&rdquo;.</p>
<p>In particular, if $X$ is path-connected, all 1-simplices $v_i,v_j$ are equivalent in the quotient: $v_i\sim v_j.$ Their common multiples are also equivalent: $nv_i\sim nv_j.$ This means that, for each $n\in\zo$, we have a class represented by $[nv_0],$ $v_0$ beinf a fixed vertex of $X.$ Thus, $H_0(X)\cong \zo.$ The same is valid using delta structures.</p>
<p>Actually, the converse is also true: if $H_0(X)\cong \zo,$ then you can find a path connecting all vertices $v_i,v_j,$ and $X$ is connected. We ommit the proof.</p>
<p>If $X$ had, say, two connected components $X_1, X_2 \subset X,$ then the vertices of $X_1$ would be identified only with themselves, and same in $X_2.$ Thus,</p>
$$H_0(X)=\angled{v_1,v_2}=H_0(X_1)\times H_0(X_2)\cong \zo^2,$$<p>for fixed vertices $v_1\in X_1, v_2\in X_2.$ In general, if $X$ has $k$ connected components, $H_0(X)\cong \zo^k.$ Thus, we may say that <strong>0-dimensional holes measure connectivity</strong>.</p>
<h2 id="disks">Disks</h2>
<p>The disk $D^2$ can be seen as the simplex $\Delta^2$. It is path-connected, so that $H_0(D^2)\cong \zo.$ For 1D cycles, we have only the boundary chain $[v_0,v_1]+[v_1,v_2]+[v_2,v_0]$ and its multiples, but they&rsquo;re all boundaries of $[v_0,v_1,v_2],$ thus being eliminated in the quotient&ndash; thus, $H_1(D^2)=0.$ Since $[v_0,v_1,v_2]$ is the only 2-chain of $\Delta^2$ and it isn&rsquo;t a cycle, $H_2(D^2)=0.$</p>
<p>In general, all the k-chains of $\Delta^n$, $k$ smaller than $n$, are bounded faces of a sub-simplex, and the only n-chain isn&rsquo;t a cycle. This proves that</p>
$$
H_n(D^k)=
\begin{cases}
\zo, & n=0 \\
0, & \text{else}
\end{cases}
$$<p>We interpret this as saying that the disks are all connected, but have no holes at any dimension.</p>
<h2 id="the-circle-and-the-spheres">The circle and the spheres</h2>
<p>IMG!!! REP DELTA</p>
<p>Using our delta structure for $S^1,$ we get that $\cdn{1}(S^1)=c\zo$ and $\cdn{0}(S^1)=v\zo$, with</p>
$$ \partial_1 c = c \mid  [v_1] - c \mid   [v_0] = c \mid  [v_0]-\sigma \mid  [v_0] = 0,$$<p>and so $\ker \partial_1=\cdn{1}(S^1).$ Since $\partial_2 = 0$ (as $\cdn{2}=0$), we have $H_1(S^1)=\angled{c}\cong\zo.$ Since the circle is connected,</p>
$$
H_n(S^1)=
\begin{cases}
\zo, & n=1, 0 \\
0, & \text{else}
\end{cases}
$$<p>We can intepret this as saying that the circle is connected and has a single 1D hole.</p>
<p>In general, the sphere $S^k$ can be seen as the boundary $\partial \Delta ^{k+1}.$ The n-chain $a$ summing all the faces of this boundary is an n-cycle, and so similarly we always have $H_k(S^k)=\angled{a}\cong\zo.$ As for the other groups with $k>0,$ they&rsquo;re trivial since every face of a face is bounded. Thus</p>
$$
H_n(S^k)=
\begin{cases}
\zo, & n=k, 0 \\
0, & \text{else}
\end{cases}
$$<p>Again, this tells us the sphere $S^k$ is connected an has a single hole at dimension $k.$</p>
<h2 id="the-torus-1">The torus</h2>
<p>IMG!!! REP DELTA</p>
<p>The delta structure we used for the torus has $\cdn{2}(T^2)=U\zo\times L\zo,$ $\cdn{1}(T^2)=a\zo\times b\zo \times c\zo$ and $\cdn{0}(T^2)=v\zo.$</p>
<p>Let&rsquo;s begin by computing all the neccesary kernels and images, then compute the homology.</p>
<ul>
<li>$\ker \partial_1$:</li>
</ul>
<p>We have that $ \partial_1 (a)=\partial_1 (b)=\partial_1 (c)=v-v=0$, so that $ \ker \partial_1 = \langle a, b, c\rangle$, the entire 1-chain space.</p>
<ul>
<li>$\im \partial_2$:</li>
</ul>
<p>As previously computed, $ \partial_2 (U) = c - b - a$ and $ \partial_2 (L) = b + a - c,$ so that $\partial U =-\partial L$. Thus, $\im \partial_2=\angled{c-b-a, a+b-c}=\angled{a+b-c}$ ($c-b-a$ is generated by $a+b-c$ as its inverse).</p>
<ul>
<li>$\ker \partial_2$:</li>
</ul>
<p>If $mU+nL\in \cdn{2}(T^2),$ then, by linearity, $\partial_2(nU+mL)=(m-n)a + (m-n)b + (n-m)c,$  for $m,n\in \zo.$ This is equal to $0$ if, and only if, $m=n,$ and then $\ker \partial_2 = \angled{nU+nL}=\angled{U+L}.$ As we saw previously, the chain $U+L$ corresponds to the whole torus surface, and thus is boundaryless.</p>
<ul>
<li>$H_1(T^2)$:</li>
</ul>
<p>With these computations, we then get that</p>
$$H_1(T)=\langle a, b, c\rangle / \langle a+b-c\rangle = \langle a, b, c\mid  a+b-c=0\rangle$$<p>But in this group $ c=a+b$, so indeed the generator $c$ is reduntant in the presentation, and $H_1(T)\cong \langle a,b\rangle\cong \mathbb{Z}^2$. So we have two 1D holes: those of the class of $a$ and those of the class of $b$, as expected!</p>
<ul>
<li>$H_2(T^2)$:</li>
</ul>
<p>For $H_2(T)$, we have $H_2(T)=\langle U+L\rangle /0=\langle U+L\rangle \cong \mathbb{Z}$ as $\cdn{3}(T^2)=0$, and we have a &ldquo;2-dimensional hole&rdquo; corresponding to the hollow surface of the torus.</p>
<p>Summarizing:</p>
$$
H_n(T^2)=
\begin{cases}
\zo, & n=2, 0 \\
\zo^2, & n=1 \\
0, & \text{else}
\end{cases}
$$<h2 id="the-klein-bottle-1">The Klein bottle</h2>
<p>IMG!!! REP DELTA</p>
<p>The delta structure we used for the Klein bottle has $\cdn{2}(K)=U\zo\times L\zo,$ $\cdn{1}(K)=a\zo\times b\zo \times c\zo$ and $\cdn{0}(K)=v\zo.$</p>
<ul>
<li>$\ker \partial_1$:</li>
</ul>
<p>The Klein bottle has $ \partial_1 (a)=\partial_1 (b)=\partial_1 (c)=0$, similar to the torus. Thus, $\ker \partial_1=\cdn{1}(K)=\angled{a,b,c}.$</p>
<ul>
<li>$\im \partial_2$:</li>
</ul>
<p>Also similar to $T^2$, $ \partial_2(U)=c-b-a$, but here $ \partial_2(L)=b-a-c$. Thus, $\im \partial_2 = \angled{-a-b+c, -a+b-c}.$ Since $(-a-b+c)+(-a+b-c)=-2a$ and $-(-a-b+c)-2a=(-a+b-c),$ $(-a-b+c)$ (and, consequently, its inverse $(a+b-c)$)and $2a$ are sufficient generators of the image: $\im \partial_2=\angled{a+b-c, 2a}.$</p>
<ul>
<li>$\ker \partial_2$:</li>
</ul>
<p>In order to the chain $nU+mL$ to be a cycle, we must have $ \partial_2(nU+mL)=-(n+m)a+(m-n)b+(n-m)c=0$. In particular, since the chain group is freely generated of the form $ \langle a,b,c\rangle $, we must have that each of the three coefficients multiplying $a,b,c$ must be zero: $m+n=n-m=m-n=0$. This is only possible if $m=n=0$, so that $\ker \partial_2 = 0$.</p>
<ul>
<li>$H_1(K)$:</li>
</ul>
<p>We have</p>
$$H_1(K)=\langle a,b,c\rangle /\langle a+b-c, 2a\rangle =\langle a,b,c\mid  a+b-c=0,2a=0\rangle$$<p>Again, $c$ is determined as $a+b$, and we may simplify to get</p>
$$H_1(K)=\langle b,a\mid  2a=0\rangle \cong \mathbb{Z}\times \mathbb{Z}/2\mathbb{Z}$$<ul>
<li>$H_2(K)$:</li>
</ul>
<p>Since $\ker \partial_2=0$, $H_2(K)=0$ as well.</p>
<p>Summarizing:</p>
$$
H_n(K)=
\begin{cases}
\zo\times\zmod{2}, & n=1 \\
\zo, & n=0 \\
0, & \text{else}
\end{cases}
$$<h2 id="the-projective-plane">The projective plane</h2>
<p>IMG!!! REP DELTA</p>
<p>The delta structure we used for the projective plane has $\cdn{2}(\rpt)=U\zo\times L\zo,$ $\cdn{1}(\rpt)=a\zo\times b\zo \times c\zo$ and $\cdn{0}(\rpt)=v_0\zo\times v_1\zo.$</p>
<ul>
<li>$\ker \partial_1$:</li>
</ul>
<p>We have that $\partial_1 a=\partial_2=v_1-v_0$ and $\partial_1 c=v_0-v_0=0.$ Thus, $\ker \partial_1=\angled{na-nb+mc},$ for $m,n\in\zo.$ This simplifies to $\angled{a-b, c}.$</p>
<ul>
<li>$\im \partial_2$:</li>
</ul>
<p>We have that $\partial_2 U=-a+b+c$ and $\partial_2 L = -a+b-c,$ so that $\im \partial_2 = \angled{-a+b+c, -a+b-c}.$ Similarly to the Klein bottle, we have $(-a+b+c)+(-a+b-c)=2(-a+b)$, and we can simplify to $\angled{-a+b+c, 2(-a+b)}.$ For convenience later, we&rsquo;ll use the inverses: $\im \partial_2=\angled{a-b-c, 2(a-b)}.$</p>
<ul>
<li>$\ker \partial_2$:</li>
</ul>
<p>For integers $n,m,$ linearity gives $\partial_2 (nU+mL)=-(n+m)a+(n+m)b+(n-m)c.$ If we want this to be null, we must have $n+m=n-m=0,$ this only being possible if $n=m=0$ and $\ker \partial_2 = 0.$</p>
<ul>
<li>$H_1(\rpt)$:</li>
</ul>
<p>We have</p>
$$H_1(\rpt)=\angled{a-b, c}/\angled{a-b-c, 2(a-b)}=\angled{a-b, c \mid (a-b)-c=0, 2(a-b)=0}$$<p>Again, $c=a-b$ is reduntant, so that $H_1(\rpt)=\angled{a-b\mid 2(a-b)=0}\cong \zmod{2}.$</p>
<ul>
<li>$H_2(\rpt)$:</li>
</ul>
<p>$\ker \partial_2=0$ forces $H_2(\rpt)=0.$</p>
<p>Summarizing:</p>
$$
H_n(\rpt)=
\begin{cases}
\zmod{2}, & n=1\\
\zo, & n=0 \\
0, & \text{else}
\end{cases}
$$<h2 id="invariance-of-the-euler-characteristic">Invariance of the Euler characteristic</h2>
<p>As we previously saw, we could define the Euler characteristic of a complex/delta structure as the alternating sum of the number $k$ of its n-dimensional chains $a_1,...,a_k.$ By definition, the rank $\rank C_n(M)$ of $C_n(M)$ is exaclty equal to this $k.$ Thus, we migh as well define the characteristic as $\chi(M)=\sum_n (-1)^n\rank C_n(M).$ Since the $C_n(M)$ change depending on the exact complex/delta structure being used, it&rsquo;s not clear that $\chi(M)$ is a topological invariant.</p>
<p>Here we&rsquo;ll need a simple algebraic fact: if $0\rightarrow A\xrightarrow{i} B\xrightarrow{j} C \rightarrow 0$ is a short exact sequence of finitely generated abelian groups, then $\rank B = \rank A + \rank C.$ You can find proofs on the internet (it&rsquo;s too wordy and dry for this text), but some examples should make this more intuitive&ndash; think of, say, direct products of $\zo.$</p>
<p>Since we have exact sequences $0\rightarrow Z_n \rightarrow C_n \xrightarrow{\partial} B_{n-1} \rightarrow 0$ and $0\rightarrow B_n \rightarrow Z_n \rightarrow H_n \rightarrow 0$ involving chain, cycle, boundary and homology groups of a space $M$, we have</p>
$$\rank C_n = \rank Z_n + \rank B_{n-1}$$$$\rank H_n = \rank Z_n - \rank B_{n}$$<p>Substituting, we have $\rank C_n = \rank H_n + \rank B_n + \rank B_{n+1}.$ This means we can sum the $\rank C_n$ alternating signs to get</p>
$$\begin{align}
\sum_n (-1)^n\rank C_n&=\sum_n (-1)^n (\rank H_n + \rank B_n + \rank B_{n+1})\\&=\sum_n (-1)^n\rank H_n,
\end{align}$$<p>since the ranks of the boundary groups cancel each other. Thus, the Euler characteristic has the formula $\chi(M)=\sum_n (-1)^n\rank H_n(M),$ which we might as well use as its &ldquo;new&rdquo; definition. Since $H_n(M)$ are topological invariants, so is $\chi(M).$ We&rsquo;ll use the characteristic later on when we classify symmetries, patterns and tilings by their symmetries using algebraic topology.</p>
<p>Our previous computations show that $\chi(T^2)=0,$ $\chi(S^n)=0$ for $n$ odd and $2$ for $n$ even, $\chi(K)=0$ and $\chi(\rpt)=1.$</p>
<h2 id="holes-of-order-2-">Holes of order 2 *</h2>
<h2 id="homology-with-coefficients">Homology with coefficients</h2>
<h1 id="applications">Applications</h1>
<h2 id="functors-retractions-and-fixed-points">Functors, retractions and fixed points</h2>
<p>Not only spaces can be studied using homology, but also continuous maps between them! If we have a continuous function $f:X\rightarrow Y$, then, for each $n$, we have the <strong>induced homomorphism</strong> $f_\#:\cdn{n}(X)\rightarrow \cdn{n}(Y)$ given by sending $\sigma:\Delta^n\rightarrow X$ to the composition $f\circ \sigma.$</p>
<p>This definition has a problem, however: nothing guarantees $f\circ \sigma$ is in the delta structure of $Y.$ To solve this, we define the <strong>singular n-chain groups</strong> $C^s_n(X)$, which is freely generated by <strong>all</strong> continuous maps $\sigma:\Delta^n\rightarrow X.$ These groups are huge, since usually there are infinitely many such functions. However, they make the theory much cleaner without actually losing anything: with the same formulas as with delta spaces, you can define the singular homology groups $H^s_n(X)$ using $\csn{n},$ and an isomorphism $H^s_n(X)\cong H_n(X)$ can be proven. Actually, you prove that complex and delta space homologies are the same by shwoing that both are isomorphic to singular homology. We&rsquo;ll sketch that later on the &ldquo;Going further&rdquo; section.</p>
<p>Now, we have no problem defining $f_\#:\csn{n}(X)\rightarrow \csn{n}Y$ for each $n$ as $f_\#(\sigma)=f\circ \sigma.$</p>
<p>We would like to extend these to homomorphisms $f_*:H_n(X)\rightarrow H_n(Y)$ for each $n$ sending the class $[h]$ to $[f_\#(h)].$ This is only well-defined, however, if it sends cycles to cycles (or else we&rsquo;d land outside of $\ker \partial_n$ in $\csn{n}(Y)$), and if $f_\#$ maps boundaries to boundaries. Otherwise, there would exist a boundary $b$ whose class is the neutral element $B_n(X)$, but being sent to a non-neutral element in $H_n(Y).$</p>
<p>Luckily, we always have $f_\#$ being well-behaved. This is because of the relation $f_\#\partial_n=\partial_{n}f_\#$: if $c$ is a cycle in $\csn{n}(X),$ then $f_\#(\partial c)=\partial(f_\#c),$ but also $f_\#(\partial c)=f_\#(0)=0,$ so that $\partial (f_\#c)=0,$ $f_\#c$ being then a cycle. If $c=\partial b$ is a boundary, $f(c)=f(\partial b)=\partial f(b)$ is also one.</p>
<p>Proving $f_\#\partial_n=\partial_{n}f_\#$ is basically just an application of $f_\#$ being, per definition, a homomorphism:</p>
$$
\begin{align}
f_\#\partial_n (\sigma) &= f_\#(\sum_i (-1)^i \sigma \mid   [v_0, ..., \widehat{v_i},..., v_n])
                     \\&= \sum_i (-1)^i f_\#(\sigma \mid   [v_0, ..., \widehat{v_i},..., v_n])=\partial_n f_\#(\sigma)
\end{align}
$$<p>Thus, the induced homomorphisms $f_*:H_n(X)\rightarrow H_n(Y)$ sending $[h]$ to $[f_\#(h)]$ are well-defined. This means homology is a theory that associated spaces $X$ to (abelian) groups $H_n(X)$, and continuous functions $f:X\rightarrow Y$ to homomorphisms $f_*:H_n(X)\rightarrow H_n(Y)$. This is called homology&rsquo;s <strong>functorial</strong> property, and the n-th homology $H_n(\cdot)$ is called a <strong>functor</strong> between spaces and groups.</p>
<p>The idea of some theory $F$ bringing mathematical objects $o$ to $Fo$ and maps $f:o\rightarrow o'$ to maps $Ff:Fo\rightarrow Fo'$ is one of the most fundamental insights of <a href="https://en.wikipedia.org/wiki/Category_theory">category theory</a> (<a href="https://en.wikipedia.org/wiki/Functor">see also</a>), and is widely applied in <a href="https://en.wikipedia.org/wiki/Functor_(functional_programming)">functional programming</a>.</p>
<p>Homology being a functor is actually a very, very useful and powerful property. First, it allows us to prove that homology is a topological invariant: if $f,g$ provide a homotopy equivalence $X\simeq Y,$ then we can prove that $f_*$ and $g_*$ are inverses in homology, giving isomorphisms $H_n(X)\cong H_n(Y).$ The proof isn&rsquo;t actually hard and introduces some useful algebraic concepts, and can be found, say, on Hatcher&rsquo;s book.</p>
<p>Functoriality is also useful when applied to <strong>retractions</strong>. Formally, a retraction from a space $X$ to a subspace $A\subseteq X$ is a continuous functions $r:X\rightarrow A$ such that $r(a)=a$ for all $a\in A.$ That is, we leave $A$ alone and send the rest of $X$ to it.</p>
<p>IMG !!!</p>
<p>Suppose we have a retraction $r:X\rightarrow A$. The chain homomorphisms $r_\#:\csn{n}(X)\rightarrow \csn{n}(A)$ are surjective since each $\sigma:\Delta^n\rightarrow A$ can be given as $r_\#(\sigma'),$ $\sigma':\Delta^n\rightarrow X$ being the exact same as $\sigma,$ but with extended range. This implies that the homology induced homomorphisms $r_* :H_n(X)\rightarrow H_n(A)$ are also surjective.</p>
<p>This simple remark shows us that <strong>there is no rectraction</strong> $r:D^2\rightarrow S^1$, since this would give a surjection $0\cong H_1(D^2) \rightarrow H_1(S^1) \cong \mathbb{Z}$, which is absurd. Intuitively, this means that if tou take a sheet of fabric and fix its boundary, it&rsquo;s impossible to retract it to the boundary without cutting the sheet. This also applies for any dimension, since retractions would imply surjections $r_*:H_n(D^{n+1})\cong 0 \rightarrow H_n(S^n)\cong \zo.$ This is a very relevant topological fact, and one that isn&rsquo;t easy at all to prove without some algebraic machinery like homology! Its relevance can be seen, for example, in how it can be used to prove this extremely useful and powerful theorem:</p>
<p><strong>Theorem (2D Brouwer&rsquo;s fixed point theorem)</strong>: Every continuous function $f:D^2\rightarrow D^2$ has a fixed point (i.e., $x$ such that $f(x)=x$).</p>
<p><strong>Proof</strong>: Suppose we had some $f:D^2\rightarrow D^2$ without fixed points, so that, for all $x$, $x\neq f(x)$. Then we can form a ray going from $x$ to $f(x)$, and this ray intersects $S^1$ at some unique point. Define $r(x)$ to be this intersection. This $r$ is then a retraction $D^2\rightarrow S^1$, which isn&rsquo;t topologically possible, so we have a contradiction.</p>
<div style="text-align: right;">\(\blacksquare\)</div>
<p>IMG !!!</p>
<p>Actually, this applies to any dimension, using the exact same argument. Thus</p>
<p><strong>Theorem (Brouwer&rsquo;s fixed point theorem)</strong>: Every continuous function $f:D^n\rightarrow D^n$ has a fixed point.</p>
<p>The theorem applies for any space $X$ homeomorphic to $D^n.$ For if $h:X\rightarrow D^n$ is a homeomorphism and we have a continuous function $f:X\rightarrow X,$ then $h\circ f\circ \inv{h}:D^n\rightarrow D^n$ has no fixed point. Suppose there was an $x\in X$ fixed by $f.$ Since $h$ is bijective, there is a $p\in D^n$ such that $\inv{h}(p)=x.$ Thus, $h(f(\inv{h}(p)))=h(\inv{h}(p))=p,$ and $p$ is a fixed point of $h\circ f\circ \inv{h},$ which is a contradiction.</p>
<p>In the 1D case, the theorem states that, if we have a continuous function $f:[a,b]\rightarrow [a,b],$ then $f(x)=x$ for some $x\in [a,b].$ We can see this through the graphic of $f$, which is contained inside the square $[a,b]^2.$ The fact that there&rsquo;s $x\in[a,b]$ such that $f(x)=x$ is equivalent to the graph of $f$ being forced to intersect the diagonal from $(a,a)$  to $(b,b)$ in the square. I.e., continuous graphs can&rsquo;t avoid touching this diagonal. This 1D example is actually a standard exercise on analysis, and can be proved only using the compactness of $[a,b]$ and the <a href="https://en.wikipedia.org/wiki/Intermediate_value_theorem">intermediate value theorem</a>&ndash; but topological methods are required for higher dimensional proofs.</p>
<p>IMG!!!</p>
<p>Brouwer&rsquo;s fixed point theorem is a very useful theorem. It is, for example, commonly used to prove that certain equations have solutions with fixed points (e.g. equations of <strong>movement</strong>, like from liquids or planetary systems). We&rsquo;re now going to study two fascinating applications to games, both fundamentally due to <a href="https://en.wikipedia.org/wiki/John_Forbes_Nash_Jr.">John Nash</a>.</p>
<h2 id="the-hex-game">The Hex game</h2>
<p>Hex is a board game invented by the norwegian polymath <a href="https://en.wikipedia.org/wiki/Piet_Hein_(scientist)">Piet Hein</a> and later further studied by Nash. It&rsquo;s played on an 11x11 hexagonal board, between two players: black (which starts) and white. Each one places a stone on a cell of the according color in its turn. Stones can&rsquo;t be taken away from the board. Black&rsquo;s objective is to connect the horizontal sides of the board by black stones, and similarly white has to connect the vertical sides. Here&rsquo;s, for example, a game won by black:</p>
<p>IMG !!!</p>
<p>Interestingly, Hex can also be played on a Go-like board, shown below. As in Go, you place stones in vertices on the board, but, unlike in Go, these vertices are not connected only in a square lattice: they also contain diagonal connections! These are such that the connectivity of the hexagonal and the Go-like board are exactly the same. Each row of vertices corresponds to a row of hexagonal cells, and you can check that the connectivities are the same.</p>
<p>IMG!!! go-like</p>
<p>You can play Hex solo and check the equivalence between the hexagonal and Go-like boards below:</p>
<p>GAME!!!</p>
<p>The fascinating thing about Hex is that is an inherently <strong>topological game</strong>, in the sense it involves connectivity, independent of any actual geometry. The relation is, however, even deeper, specifically when you consider the possible end results of the game. What results are possible? Since we have a finite board, we must have that each game either leads to a black win, to a white victory or a draw. This last ending, however, is <strong>impossible</strong>, and this is an application of Brouwer&rsquo;s fixed point theorem!</p>
<p><strong>Theorem</strong>: No Hex game can end in a draw.</p>
<p><strong>Proof</strong>:</p>
<p>The proof is appliable to any $k\times k$ board (actually to any dimensions, the proof being identical).</p>
<p>First, note that the Go-like board gives us a <strong>triangulation</strong> of the square $D_k=[0,k]\times [0,k]$ (with the connections giving the edges of the triangles), which is homeomorphic to a 2D disk. Denote this complex as $B_k$. Assuming there exists a Hex game without a winner, we will construct a map $f:D_k\rightarrow D_k$ without a fixed point, which is a contradiction.</p>
<p>Since $D_k$ is triangulated by $B_k$, every element $x$ of $D_k$ can be written uniquely in barycentric coordinates as a linear combination $x=\lambda_0 v_0 + \lambda_1 v_1 +\lambda_2 v_2$, for $v_0,v_1,v_2$ vertices of $B_k$ forming the triangle containing $x$, and $\lambda_0+\lambda_1+\lambda_2=1$,  $\lambda_i\geq 0$. Remember that this means that every function $f:B_k\rightarrow \rt$ can extend to one $\widehat{f}:D_k\rightarrow \rt$ by defining $\widehat{f}(\lambda_0 v_0 + \lambda_1 v_1 +\lambda_2 v_2)=\lambda_0 f(v_0) + \lambda_1 f(v_1) +\lambda_2 f(v_2)$.</p>
<p>Let $H, V$ denote the sets the positions of black (<em>Horizotal</em>-winning) and white (<em>Vertical</em>-winning) pieces on a board, respectively.</p>
<p>Assume that we have $H,V$ such that there is no Hex winner. Now, let us define a function $f:B_k\rightarrow B_k$ which will be extended to $\widehat{f}:D_k\rightarrow D_k$ that will lead to the contradiction. Define $\widehat{W}$ to be the subset of $H$ connected to the western extreme $W$, and similarly for $\widehat{E}\subset H$, $\widehat{S}\subset V$ and $\widehat{N}\subset V$. The assumption we have no winner is equivalent to saying that $\widehat{W} \neq \widehat{E}$ and $\widehat{S} \neq \widehat{N}$, or that $\widehat{W}$ (or $\widehat{S}$) and $\widehat{E}$ (or $\widehat{N}$) are connected. Then define $f$ as</p>
$$
\begin{align}
f(z)  &= z + (1, 0) \;\;\; \text{for} \; z\in \widehat{W} 
    \\&= z - (1, 0) \;\;\; \text{for} \; z\in \widehat{E} 
    \\&= z + (0, 1) \;\;\; \text{for} \; z\in \widehat{S} 
    \\&= z - (0, 1) \;\;\; \text{for} \; z\in \widehat{N} 
\end{align}
$$<p>That is, we push elements of each set towards the winning direction. Since we assume this is a draw, doing so would still leave us inside the board $B_k$, so that indeed the function has type $f:B_k\rightarrow B_k$. We define $e(z)$ to be the vector $z$ is pushed by $f$. You can understand the vector $e(z)$ as giving you a victory direction, and $f(z)$ making $z$ follow this <strong>&ldquo;winning flow&rdquo;</strong>. Extending $f$ as we described above, we have a map $\widehat{f}:D_k\rightarrow D_k$.</p>
<p>Note in particular that three points $v_0,v_1,v_2$ forming a triangle in $B_k$ can&rsquo;t have a pair $v_i, v_j$ such that $e(v_i)=-e(v_j)$, because that would imply $\widehat{W}$ and $\widehat{E}$ (or $\widehat{S}$ and $\widehat{N}$) are connected, and we would have a winner!</p>
<p>By definition, if $x = \lambda_0 v_0 + \lambda_1 v_1 +\lambda_2 v_2$, then it is a fixing point of $\widehat{f}(x)$ only if</p>
$$\begin{align}
\widehat{f}(x)=\lambda_0 f(v_0) + \lambda_1 f(v_1) +\lambda_2 f(v_2) &= \lambda_0(v_0+e(v_0)) + \lambda_1(v_1+e(v_1)) + \lambda_2(v_2+e(v_2))
\\&=\lambda_0 v_0 + \lambda_1 v_1 +\lambda_2 v_2=x
\end{align}$$<p>This forces $\lambda_1e(v_0)+\lambda_1e(v_1)+\lambda_2e(v_2)=0$, which amounts to say that the 2-simplex generated by $e(v_0),e(v_1),e(v_2)$ contains the origin. This is only possible if some of these three vectors are inverses. However, as noted above, this is a contradiction! Thus, Hex can&rsquo;t have draws.</p>
<div style="text-align: right;">\(\blacksquare\)</div>
<p>The result is actually even stronger: Hex having no draws is <strong>equivalent</strong> to the 2D Brouwer fixed point theorem. The proof requires some use of real analysis, so we won&rsquo;t write it here. See the references for a proof.</p>
<p>The interactive game above shows this winning flow, it being null at positions without any placed stones. Colors represent the direction (and length by their intensity) of the flow vectors, according to the color-coding shown in the disk below (right is blue-ish, up is red-ish, left is green-ish and down is cyan). Black indicates null-flow.</p>
<p>IMG !!! circulo</p>
<p>IMG!!!!  jogo e exemplo</p>
<p>By <a href="https://en.wikipedia.org/wiki/Zermelo%27s_theorem_(game_theory)">Zermelo&rsquo;s Theorem</a>, since Hex has no draws, there must be a winning strategy for either black or white. Well, if white&ndash; the second player&ndash; had such a strategy, then black could begin with a generic move and then immitate it. Since in Hex a placed stone can never be a disadvantage, black&rsquo;s first stone wouldn&rsquo;t stop them from following the immitated winning strategy. Thus, if white had such a forced win, black would have one as well&ndash; which is a contradiction. Thus, it must be that <strong>black&ndash; the first player&ndash; has a winning strategy from the beginning</strong>.</p>
<p>In that sense, Hex is &ldquo;solved&rdquo;. But note that we didn&rsquo;t actually construct this strategy, and the &ldquo;perfect Hex game&rdquo; is still unknown. The strategies for the 7x7, 8x8 and 9x9 boards, however, have been found.</p>
<h1 id="going-further">Going further</h1>
<h2 id="homotopy-invariance-of-homology">Homotopy invariance of homology</h2>
<p>To prove that <em>singular</em> homology is a topological invariant, it&rsquo;s actually easier to prove that two spaces $X,Y$ with the same <em>homotopy</em> type (which includes homeomorphic spaces) have the same homology groups.</p>
<p>We can actually prove even more: if $f$ and $g$ are homotopic maps, then they have exactly the same induced homomorphisms on homology: $f_*=g_*.$ This includes the previous claim, since if $f:X\rightarrow Y$ and $g:Y\rightarrow X$ provide a homotopy equivalence $X\simeq Y,$ then $f\circ g\simeq \text{id}$ and thus $f_*\circ g_*=\text{id},$ so that $f_*$ and $g_*$ are inverses, giving an isomorphism $H_*(X)\cong H_*(Y).$</p>
<p>Thus, let $F:X\rightarrow I\rightarrow Y$ be a homotopy between maps $f$ and $g$ as above. Now, the essential (and actually quite simple, <strong>check Hatcher</strong>) part of the proof is to provide a triangulation of $\Delta^n\times I$ for all standard simplices&ndash; with $\Delta^2$, for example, this is just a triangulation of a square, especifically using a quad.</p>
<h2 id="long-exact-sequences-excision">Long exact sequences, excision</h2>
<p>What is the relation between the homology of a space $X$ and of a subspace $A\subseteq X$&ndash; or, more generally, of subspaces $A_i\subseteq X$? If we can cover $X$ by open subsets $A_i,$ can the homology of $X$ be deduced by that of $A_i$? If we know the homologies of $A$ and $X$ can we find that of the quotient $X/A$?</p>
<p>Surprisingly, even though these are quite general questions, they have positive answers&ndash; actually, even a single answer!</p>
<p>Take first the example of a quotient $X/A,$ with $A\subset X$ initially any subspace of $X.$ Define the <strong>relative chain group</strong> $C_n(X, A)$ as the group quotient $C_n(X)/C_n(A).$ Basically, this represents classes of chains in $X,$ seen as equivalent if they only differ inside $A.$ Every such class $[c]\in C_n(X,A)$ induces a single one in $C_n(X/A)$ as $p\circ c,$ with $p:X\rightarrow X/A$ the quotient projection, exactly because all elements of $[c]$ have the same behaviour on $X.$ The homology of the chain $C_n(X,A)$ is called the <strong>relative homology</strong> $H_n(X,A)$ and is deeply related to $H_n(X/A),$ as we&rsquo;ll see.</p>
<p>Now, for all $n,$ we have an exact sequence (as we do in every group quotient)</p>
$$0\rightarrow C_n(A) \xrightarrow{i_*} C_n(X) \xrightarrow{p_*} C_n(X, A) \rightarrow 0$$<p>where $i:A\rightarrow X$ is the inclusion and $p:X\rightarrow X/A$ the projection.</p>
<p>How do we go from that to homology groups? Take the prototypical example of the pair $(D^2, S^1),$ with the quotient $D^2/S^1=S^2.$ Here is the relative chain complex $C_n(D^2, S^1)$ (beginning with $C_2(D^2,S^1)$) using simplicial chains:</p>
$$...\rightarrow \zo \rightarrow \zo^3/\zo^3=0 \rightarrow \zo^3/\zo^3=0\rightarrow 0$$<p>The homology of this complex has $H_n(X,A)=\zo$ for $n=2$ and is trivial elsewhere. That is, $H_n(X,A)\cong \widetilde{H}_n(X/A)$ in this case, with the generator of the relative homology $H_2(X,A)$ being collapsed to the generator of $H_2(X/A)$ by the quotient&ndash; that is, to the whole surface $[S^2]$ of the sphere.</p>
<p>We then see that, in this case, the generator $[S^2]$ of $H_2(X/A)$ is obtained when you collapse $A$ to a single point. But this $A$ is a cycle in $X.$ It is bounded in $X,$ but clearly not in $A$ itself. Thus, if we associate $[S^2]$ to $A,$ and restrict to chains inside $A$, we get a map $H_2(X/A)\rightarrow H_1(A).$ This is our motto: <strong>return, boundary and restriction</strong>.</p>
<p>Now, consider $X$ being covered by two open sets $A,B.$ We then have the exact sequence</p>
$$0\rightarrow C_n(A\cap B) \xrightarrow{x\mapsto(x, -x)} C_n(A)\times C_n(B) \xrightarrow{(x,y)\mapsto x+y} C_n(A\cup B)  \rightarrow 0$$<p>That is,&hellip;</p>
<p>Here, the prototypical example is $S^2$ covered by two hemisphere $A,B$ intersecting in a neighborhood of the equator. This neighborhood, thus, is homotopy equivalent to $S^1$ (the equator itself). Now, every chain $c$ in $C_n(A\cup B)$ can be expressed as a sum $c=x+y$ of (potentially null) chains $x$ in $A$ and $y$ in $B.$ In the example, the whole surface of $S^2$ can be expressed as the sum of the singular chains $\bar{A}$ and $\bar{B}.$ If this chain $c$ is a cycle, then $\partial c = \partial x + \partial y =0,$ and thus $\partial x = - \partial y.$ Thus, $(\partial x, \partial y)$ is in the image of the $C_{n-1}(A\cap B) \rightarrow C_{n-1}(A)\times C_{n-1}(B)$ as above, so that $\partial x=\alpha$, for some $\alpha \in C_{n-1}(A\cap B)$&ndash; which, since $\partial^2=0,$ must be a cycle. That whole process then associates a cycle $c\in Z_n(A\cup B)$ to one $\alpha$ in $Z_{n-1}(A\cap B)$&ndash; again, by the process of returning, doing the boundary and restricting. We then pass to homology classes and get a map $H_n(A\cup B)\rightarrow H_{n-1}(A\cap B).$</p>
$$0\rightarrow Z_n \xrightarrow{i} C_n \xrightarrow{\partial} B_{n-1}  \rightarrow 0$$$$...\rightarrow H_n(A)\rightarrow H_n(X) \rightarrow H_n(X,A)\rightarrow H_{n-1}(A)\rightarrow ...$$$$...\rightarrow \widetilde{H}_n(A)\rightarrow \widetilde{H}_n(X) \rightarrow \widetilde{H}_n(X/A)\rightarrow \widetilde{H}_{n-1}(A)\rightarrow ...$$<p>The long exact sequence for the short exact sequence of an open covering $X=A\cup B$ as we did above is also known as the <strong>Mayer-Vietoris sequence</strong>, and has the form</p>
$$...\rightarrow H_n(A\cap B)\rightarrow H_n(A)\oplus H_n(B)\rightarrow H_n(A\cup B)\rightarrow H_{n-1}(A\cap B)\rightarrow ...$$<p>For example, covering the torus $T^2$ with two open cylinders $A,B$ such that they meet at another two open and disjoint cylinders, we get that $A,B\simeq S^1,$ $A\cap B \simeq S^1 \amalg S^1$ and so the Mayer-Vietoris sequence reads as</p>
$$...\rightarrow 0 \rightarrow H_2(T^2)\rightarrow H_1(S^1)\oplus H_1(S^1)=\zo \oplus \zo \rightarrow H_1(S^1\amalg S^1)=\zo \oplus\zo  
\rightarrow H_1(T)$$$$\rightarrow H_0(S^1)\oplus H_0(S^1)=\zo \oplus \zo \rightarrow  H_0(S^1\amalg S^1)=\zo \oplus \zo
\rightarrow H_0(T)\rightarrow 0$$<p>The map $H_2(T^2)\rightarrow H_1(S^1\amalg S^1)$</p>
<h2 id="isomorphism-of-simplicial-delta-and-singular-homologies">Isomorphism of simplicial, delta and singular homologies</h2>
<h2 id="cw-complexes-and-cellular-homology">CW complexes and cellular homology</h2>
<p>CW COMPLEXOS</p>
<p>RPN, CPN</p>
<p>H_*(X_N,X_N-1)</p>
<p>DESCRIÇÃO DO BOUNDARY</p>
<p>CPN, RPN (COEFICS TBM)</p>


<p>
  
  <a href="http://localhost:1313/blog/topology-for-artists/">#Topology for Artists</a>
  
</p>

  </main>

  <footer>
</footer>

    

    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "your-disqus-shortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  
</body>

</html>
